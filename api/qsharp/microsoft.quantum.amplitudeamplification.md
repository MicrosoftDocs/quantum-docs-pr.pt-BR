---
uid: Microsoft.Quantum.AmplitudeAmplification
title: Namespace Microsoft. Quantum. AmplitudeAmplification
ms.date: 10/26/2020 12:00:00 AM
ms.topic: article
qsharp.kind: namespace
qsharp.name: Microsoft.Quantum.AmplitudeAmplification
qsharp.summary: This namespace contains functions and operations for performing amplitude amplification.
ms.openlocfilehash: 09c29bd9d0648bb8652051ad97ceca6ef6557df3
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/27/2020
ms.locfileid: "92694902"
---
# <a name="microsoftquantumamplitudeamplification-namespace"></a><span data-ttu-id="cc721-102">Namespace Microsoft. Quantum. AmplitudeAmplification</span><span class="sxs-lookup"><span data-stu-id="cc721-102">Microsoft.Quantum.AmplitudeAmplification namespace</span></span>

<span data-ttu-id="cc721-103">Este namespace contém funções e operações para executar amplificação de amplitude.</span><span class="sxs-lookup"><span data-stu-id="cc721-103">This namespace contains functions and operations for performing amplitude amplification.</span></span>



## <a name="description"></a><span data-ttu-id="cc721-104">Descrição</span><span class="sxs-lookup"><span data-stu-id="cc721-104">Description</span></span>

<span data-ttu-id="cc721-105">A amplificação de amplitude alheios com reflexos parciais é a forma mais geral de amplificação de amplitude implementada aqui.</span><span class="sxs-lookup"><span data-stu-id="cc721-105">Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here.</span></span>

<span data-ttu-id="cc721-106">Isso é chamado por meio da operação AmpAmpObliviousByReflectionPhases.</span><span class="sxs-lookup"><span data-stu-id="cc721-106">This is called through the operation AmpAmpObliviousByReflectionPhases.</span></span>

<span data-ttu-id="cc721-107">Isso tem dois registros: `ancillaRegister` e `systemRegister` .</span><span class="sxs-lookup"><span data-stu-id="cc721-107">This has two registers: `ancillaRegister` and `systemRegister`.</span></span>

<span data-ttu-id="cc721-108">Isso aceita dois Oracle para esses reflexos do tipo `ReflectionOracle` que atuam apenas no `ancillaRegister` registro.</span><span class="sxs-lookup"><span data-stu-id="cc721-108">This accepts two oracles for these reflections of type `ReflectionOracle` which act only on the `ancillaRegister` register.</span></span>

<span data-ttu-id="cc721-109">Isso aceita um Oracle Special para amplificação de amplitude de alheios do tipo `ObliviousOracle` que atua em conjunto em ambos os registros.</span><span class="sxs-lookup"><span data-stu-id="cc721-109">This accepts an oracle special to oblivious amplitude amplification of type `ObliviousOracle` which acts jointly on both register.</span></span>

<span data-ttu-id="cc721-110">O estado de entrada para `ancillaRegister` é considerado o único $-$1 eigenstate do primeiro operador de reflexão $I-2 \ ket {s} \ Bra {s} $.</span><span class="sxs-lookup"><span data-stu-id="cc721-110">The input state to `ancillaRegister` is assumed to be the unique $-1$ eigenstate of the first reflection operator $I - 2\ket{s}\bra{s}$.</span></span>

<span data-ttu-id="cc721-111">Os reflexos sobre um estado de Quantum de destino geralmente são implementados supondo-se o acesso a um Oracle que prepare esse estado da base computacional $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="cc721-111">Reflections about a target quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis $\ket{0\cdots 0}$.</span></span>

<span data-ttu-id="cc721-112">Nossa Convenção para esses Oracle requer dois registros: um registro de qubit único `flagQubit` e um registro para todo o restante no registro de ancillaRegister.</span><span class="sxs-lookup"><span data-stu-id="cc721-112">Our convention for these oracles requires two registers: a single-qubit `flagQubit` register, and a register for everything else on the ancillaRegister register.</span></span>

<span data-ttu-id="cc721-113">O Oracle do tipo `StateOracle` atua em conjunto em ambos os registros para criar o estado de destino sinalizado por $ \ket {1} $ no `flagQubit` registro com alguma amplitude real.</span><span class="sxs-lookup"><span data-stu-id="cc721-113">The oracle of type `StateOracle` acts jointly on both registers to create the target state flagged by $\ket{1}$ in the `flagQubit` register with some real amplitude.</span></span>

<span data-ttu-id="cc721-114">A reflexão `ReflectionOracle` sobre o estado desse sinalizador é gerada pela operação `TargetStateReflectionOracle` .</span><span class="sxs-lookup"><span data-stu-id="cc721-114">The reflection `ReflectionOracle` about the this flag state is generated by the operation `TargetStateReflectionOracle`.</span></span>

<span data-ttu-id="cc721-115">A reflexão `ReflectionOracle` sobre o estado de entrada para `ancillaRegister` é gerada pelo inverso de StateOracle e, em seguida, pela reflexão de $ \ket{0\cdots 0} $ com ReflectionStart ().</span><span class="sxs-lookup"><span data-stu-id="cc721-115">The reflection `ReflectionOracle` about the input state to `ancillaRegister` is generated by the inverting StateOracle and then reflecting about $\ket{0\cdots 0}$ with ReflectionStart().</span></span>

<span data-ttu-id="cc721-116">O Oracle do tipo `DeterministicStateOracle` atua nos `qubitState` registros para criar o estado de destino exatamente sem sinalizador.</span><span class="sxs-lookup"><span data-stu-id="cc721-116">The oracle of type `DeterministicStateOracle` acts on the `qubitState` registers to create the target state exactly with no flag.</span></span>

<span data-ttu-id="cc721-117">`AmpAmpObliviousByOraclePhases` é uma versão da amplificação de amplitude alheios que aceita ORACLES `StateOracle` e `ObliviousOracle` em vez de reflexos.</span><span class="sxs-lookup"><span data-stu-id="cc721-117">`AmpAmpObliviousByOraclePhases` is a version of oblivious amplitude amplification that accepts oracles `StateOracle` and `ObliviousOracle` instead of reflections.</span></span>

<span data-ttu-id="cc721-118">Observe que a amplificação de amplitude é um caso especial de amplificação de amplitude alheios em que `ObliviousOracle` é o operador Identity, e não há nenhum qubits de sistema, ou seja, `systemRegister` está vazio.</span><span class="sxs-lookup"><span data-stu-id="cc721-118">Note that amplitude amplification is a special case of oblivious amplitude amplification where `ObliviousOracle` is the identity operator, and there are no system qubits i.e. `systemRegister` is empty.</span></span>

<span data-ttu-id="cc721-119">Isso é chamado por meio da operação `AmpAmByReflectionPhases` e `AmpAmpByOraclePhases` .</span><span class="sxs-lookup"><span data-stu-id="cc721-119">This is called through the operation `AmpAmByReflectionPhases` and `AmpAmpByOraclePhases`.</span></span>

<span data-ttu-id="cc721-120">As fases para reflexões parciais no caso padrão da pesquisa Grover são fornecidas pela função AmpAmpPhasesStandard.</span><span class="sxs-lookup"><span data-stu-id="cc721-120">The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesStandard.</span></span>

<span data-ttu-id="cc721-121">Por exemplo, temos as seguintes dependências: AmpAmpByOracle-> AmpAmpByOraclePhases-> AmpAmpObliviousByOraclePhases-> AmpAmpObliviousByReflectionPhases.</span><span class="sxs-lookup"><span data-stu-id="cc721-121">For instance, we have the following dependencies: AmpAmpByOracle -> AmpAmpByOraclePhases -> AmpAmpObliviousByOraclePhases -> AmpAmpObliviousByReflectionPhases.</span></span>