---
title: 'P # bibliotecas padrão – aplicativos | Microsoft Docs'
description: Bibliotecas padrão Q#
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 3e629e095bd2ee492496066710ef6fd4e578a543
ms.sourcegitcommit: ca5015fed409eaf0395a89c2e4bc6a890c360aa2
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/29/2020
ms.locfileid: "76868961"
---
# <a name="applications"></a><span data-ttu-id="b6d79-103">Aplicativos</span><span class="sxs-lookup"><span data-stu-id="b6d79-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="b6d79-104">Simulação hamiltoniana</span><span class="sxs-lookup"><span data-stu-id="b6d79-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="b6d79-105">A simulação de sistemas Quantum é um dos aplicativos mais empolgantes da computação Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="b6d79-106">Em um computador clássico, a dificuldade de simular a mecânica quantum, em geral, é dimensionada com a dimensão $N $ de sua representação de vetor de estado.</span><span class="sxs-lookup"><span data-stu-id="b6d79-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="b6d79-107">Como essa representação aumenta exponencialmente com o número de $n $ qubits $N = 2 ^ n $, uma característica conhecida também conhecida como o tempo [de indimensão](xref:microsoft.quantum.concepts.multiple-qubits), a simulação da Quantum no hardware clássico é inmanejável.</span><span class="sxs-lookup"><span data-stu-id="b6d79-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="b6d79-108">No entanto, a situação pode ser muito diferente no hardware Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="b6d79-109">A variação mais comum da simulação do Quantum é chamada de problema de simulação de Hamiltonian de tempo independente.</span><span class="sxs-lookup"><span data-stu-id="b6d79-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="b6d79-110">Lá, é fornecida uma descrição do sistema Hamiltonian $H $, que é uma matriz Hermitian, e algum estado inicial de Quantum $ \ket{\psi (0)} $ que é codificado de acordo com a $n $ qubits em um computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="b6d79-111">Como os Estados da Quantum em sistemas fechados evoluem na equação Schrödinger $ $ \begin{align} i\frac {d \ket{\psi (t)}} {d t} & = H \ket{\psi (t)}, \end{align} $ $ o objetivo é implementar o operador de evolução temporal $U (t) = e ^ {-iHt} $ em um período fixo $t $ , em que $ \ket{\psi (t)} = U (t) \ket{\psi (0)} $ resolve a equação Schrödinger.</span><span class="sxs-lookup"><span data-stu-id="b6d79-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="b6d79-112">De forma semelhante, o problema de simulação de Hamiltonian dependente de tempo resolve a mesma equação, mas com $H (t) $ agora é uma função de tempo.</span><span class="sxs-lookup"><span data-stu-id="b6d79-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="b6d79-113">A simulação de Hamiltonian é um componente importante de muitos outros problemas de simulação de Quantum, e soluções para o problema de simulação de Hamiltonian são algoritmos que descrevem uma sequência de Gates de Quantum primitivo para sintetizar um aproximar unitário $ \tilde{U} $ com erro $\\| \tilde{U}-U (t)\\| \le \epsilon $ na [norma Spectral](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="b6d79-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="b6d79-114">A complexidade desses algoritmos depende muito de como uma descrição dos Hamiltonian de interesse é disponibilizada por um computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="b6d79-115">Por exemplo, na pior das hipóteses, se $H $ agindo em $n $ qubits fosse fornecida como uma lista de $2 ^ n \times 2 ^ n $ Numbers, uma para cada elemento de matriz, simplesmente ler os dados já exigiria tempo exponencial.</span><span class="sxs-lookup"><span data-stu-id="b6d79-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="b6d79-116">Na melhor das hipóteses, é possível assumir o acesso a um unitário de caixa preta que $O \ket{t}\ket{\psi (0)} = \ket{t}U (t) \ket{\psi (0)} $ resolve o problema de forma trivial.</span><span class="sxs-lookup"><span data-stu-id="b6d79-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="b6d79-117">Nenhum desses modelos de entrada é particularmente interessante – o primeiro, pois não é melhor do que as abordagens clássicas, e a última opção é que a caixa preta oculta a complexidade do portão primitivo de sua implementação, que poderia ser exponencial no número de qubits.</span><span class="sxs-lookup"><span data-stu-id="b6d79-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="b6d79-118">Descrições de Hamiltonians</span><span class="sxs-lookup"><span data-stu-id="b6d79-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="b6d79-119">Portanto, as suposições adicionais do formato da entrada são necessárias.</span><span class="sxs-lookup"><span data-stu-id="b6d79-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="b6d79-120">Um equilíbrio fino deve ser riscado entre os modelos de entrada que são suficientemente descritivos para abranger Hamiltonians interessantes, como aqueles para sistemas físicos realísticos ou problemas computacionais interessantes e modelos de entrada que são suficientemente restritivos ser implementado de forma eficiente em um computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="b6d79-121">Uma variedade de modelos de entrada não triviais pode ser encontrada na literatura e varia de Quantum para clássico.</span><span class="sxs-lookup"><span data-stu-id="b6d79-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="b6d79-122">Como exemplos de modelos de entrada Quantum, [a simulação de Hamiltonian baseada em amostras](http://www.nature.com/articles/s41534-017-0013-7) assume o acesso de caixa preta a operações Quantum que produzem cópias de uma matriz de densidade $ \rho $, que são levadas a Hamiltonian $H $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="b6d79-123">No [modelo de acesso unitário](https://arxiv.org/abs/1202.5822) , um pressupõe que o Hamiltonian, em vez disso, é decomposto em uma soma de unidades $ $ \begin{align} H & = \sum ^ {d-1}\_{j = 0} a\_j \hat{U}\_j, \end{Align} $ $, em que $a\_j > 0 $ são coeficientes e $ \hat{U}\_j $ são unidades.</span><span class="sxs-lookup"><span data-stu-id="b6d79-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="b6d79-124">Em seguida, supõe-se que um tenha acesso de caixa preta ao Oracle $V unitário = \sum ^ {d-1}\_{j = 0} \ket{j}\bra{j}\otimes \hat{U}\_j $ que selecione o $ \hat{U}\_j $ desejado, e o Oracle $A \ket{0}= \sum ^ {d-1}\_{j = 0} \sqrt{a\_j/\ Sum ^ {d-1}\_{k = 0} \alpha\_j} \ket{j} $ que criam uma codificação de estado Quantum com esses coeficientes.</span><span class="sxs-lookup"><span data-stu-id="b6d79-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="b6d79-125">No caso da [simulação de Hamiltonian esparsa](https://arxiv.org/abs/quant-ph/0301023), uma assume que o Hamiltonian é uma matriz esparsa com apenas $d = \mathcal{O} (\Text{polylog} (N)) $ non-zero elemento em cada linha.</span><span class="sxs-lookup"><span data-stu-id="b6d79-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="b6d79-126">Além disso, um assume a existência de circuitos Quantum eficientes que geram o local desses elementos diferentes de zero, bem como os respectivos valores.</span><span class="sxs-lookup"><span data-stu-id="b6d79-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="b6d79-127">A complexidade dos [algoritmos de simulação de Hamiltonian](xref:microsoft.quantum.more-information) é avaliada em termos de número de consultas a essas caixas pretas, e a complexidade do portão primitivo depende muito da dificuldade de implementar essas caixas pretas.</span><span class="sxs-lookup"><span data-stu-id="b6d79-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="b6d79-128">A notação de Big-o geralmente é usada para descrever o dimensionamento da complexidade dos algoritmos.</span><span class="sxs-lookup"><span data-stu-id="b6d79-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="b6d79-129">Dadas duas funções reais $f, g $, a expressão $g (x) = \mathcal{O} (f (x)) $ significa que existe uma constante positiva absoluta $x\_0, c > 0 $ de modo que $g (x) \le c f (x) $ para todos os $x \ge x\_$0.</span><span class="sxs-lookup"><span data-stu-id="b6d79-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="b6d79-130">Na maioria dos aplicativos práticos a serem implementados em um computador Quantum, essas caixas pretas devem ser implementadas de forma eficiente, ou seja, com as Gates $ \mathcal{O} (\Text{polylog} (N)) $ Primitive Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="b6d79-131">De forma mais forte, simulable Hamiltonians deve ter uma descrição clássica suficientemente esparsa.</span><span class="sxs-lookup"><span data-stu-id="b6d79-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="b6d79-132">Em uma dessas formulações, supõe-se que Hamiltonian é decomposto de uma soma de Hermitian partes $ $ \begin{align} H & = \sum ^ {d-1} _ {j = 0} H_j.</span><span class="sxs-lookup"><span data-stu-id="b6d79-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="b6d79-133">\end{align} $ $ mais, presume-se que cada parte, um Hamiltonian $H\_j $, seja fácil de simular.</span><span class="sxs-lookup"><span data-stu-id="b6d79-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="b6d79-134">Isso significa que o unitário $e ^ {-iH\_j t} $ para qualquer hora $t $ pode ser implementado exatamente usando as Gates $ \mathcal{O} (1) $ Primitive Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="b6d79-135">Por exemplo, isso é verdadeiro no caso especial em que cada $H\_j $ são operadores de Pauli locais, o que significa que eles são de produtos tensor de $ \mathcal{O} (1) $ não Identity Pauli Operators que atuam em qubits de fechamento espacial.</span><span class="sxs-lookup"><span data-stu-id="b6d79-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="b6d79-136">Esse modelo é particularmente aplicável a sistemas físicos com interação vinculada e local, uma vez que o número de termos é $d = \mathcal{O} (\Text{polylog} (N)) $ e pode ser escrito claramente, ou seja, descrito de forma clássica, em tempo polinomial.</span><span class="sxs-lookup"><span data-stu-id="b6d79-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="b6d79-137">Hamiltonians que decompõem uma soma de partes podem ser descritos usando a biblioteca de representação do gerador dinâmico.</span><span class="sxs-lookup"><span data-stu-id="b6d79-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="b6d79-138">Para obter mais informações, consulte a seção representação do gerador dinâmico em [estruturas de dados](xref:microsoft.quantum.libraries.data-structures).</span><span class="sxs-lookup"><span data-stu-id="b6d79-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="b6d79-139">Algoritmos de simulação</span><span class="sxs-lookup"><span data-stu-id="b6d79-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="b6d79-140">Um algoritmo de simulação do Quantum converte uma determinada descrição de um Hamiltonian em uma sequência de Gates de Quantum primitivos que, como um todo, uma evolução de tempo aproximada disse Hamiltonian.</span><span class="sxs-lookup"><span data-stu-id="b6d79-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="b6d79-141">No caso especial em que o Hamiltonian é decomposto em uma soma de partes Hermitian, a decomposição Trotter-Suzuki é um algoritmo especialmente simples e intuitivo para simular Hamiltonians que decompõem uma soma de componentes Hermitian.</span><span class="sxs-lookup"><span data-stu-id="b6d79-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="b6d79-142">Por exemplo, um integrador de primeiro pedido desta família aproxima $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \cdots e ^ {-iH\_{d-1} t/r} \right) ^ {r} + \mathcal{O} (d ^ 2 \ max_j\\| H\_j\\| ^ 2 t ^ 2/r), \end{align} $ $ usando um produto de $r d $ termos.</span><span class="sxs-lookup"><span data-stu-id="b6d79-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="b6d79-143">Os aplicativos do algoritmo de simulação Trotter-Suzuki são abordados nos exemplos.</span><span class="sxs-lookup"><span data-stu-id="b6d79-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="b6d79-144">Para o modelo Ising usando apenas as operações intrínsecas fornecidas por cada computador de destino, consulte o [exemplo **SimpleIsing** ](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span><span class="sxs-lookup"><span data-stu-id="b6d79-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="b6d79-145">Para o modelo Ising usando a estrutura de controle de biblioteca Trotter-Suzuki, consulte o [exemplo **IsingTrotter** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span><span class="sxs-lookup"><span data-stu-id="b6d79-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="b6d79-146">Para molecular Hydrogen usando a estrutura de controle de biblioteca Trotter-Suzuki, consulte o exemplo de [ **simulação H2** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span><span class="sxs-lookup"><span data-stu-id="b6d79-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="b6d79-147">Em muitos casos, gostaríamos de implementar o algoritmo de simulação, mas não estamos interessados nos detalhes de sua implementação.</span><span class="sxs-lookup"><span data-stu-id="b6d79-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="b6d79-148">Por exemplo, o integrador de segunda ordem aproxima $ $ \begin{align} U (t) & = \left (e ^ {-iH\_0 t/2R} e ^ {-iH\_1 t/2R} \cdots e ^ {-iH\_{d-1} t/2R} e ^ {-iH\_{d-1} t/2R} \cdots e ^ {-iH\_1 t/2R} e ^ {-iH\_0 t/2R} \right) ^ {r} + \mathcal{O} (d ^ 3 \ max_j\\| H\_j\\| ^ 3 t ^ 3/r ^ 2), \end{align} $ $ usando um produto de $2rd $ termos.</span><span class="sxs-lookup"><span data-stu-id="b6d79-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="b6d79-149">Ordens maiores envolverão ainda mais termos e variantes otimizadas podem exigir ordenações altamente não triviais em exponencials.</span><span class="sxs-lookup"><span data-stu-id="b6d79-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="b6d79-150">Outros algoritmos avançados também podem envolver o uso de ancilla qubits em etapas intermediárias.</span><span class="sxs-lookup"><span data-stu-id="b6d79-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="b6d79-151">Portanto, empacotamos algoritmos de simulação na Canon como o tipo definido pelo usuário</span><span class="sxs-lookup"><span data-stu-id="b6d79-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="b6d79-152">O primeiro parâmetro `Double` é a hora da simulação, o segundo parâmetro `EvolutionGenerator`, abordado na seção representação do gerador dinâmico de [estruturas de dados](xref:microsoft.quantum.libraries.data-structures), é uma descrição clássica de um Hamiltonian de tempo independente fornecido com instruções sobre como cada termo no Hamiltonian pode ser simulado por um circuito Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="b6d79-153">Tipos desse formulário aproximam a operação de unitário $e ^ {-iHt} $ no terceiro parâmetro `Qubit[]`, que é o registro que armazena o estado Quantum do sistema simulado.</span><span class="sxs-lookup"><span data-stu-id="b6d79-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="b6d79-154">Da mesma forma, para o caso dependente de tempo, definimos um tipo definido pelo usuário com um `EvolutionSchedule` tipo, que é uma descrição clássica de um Hamiltonian dependente de tempo.</span><span class="sxs-lookup"><span data-stu-id="b6d79-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="b6d79-155">Por exemplo, a decomposição Trotter-Suzuki pode ser chamada usando as seguintes funções de Canon, com parâmetros `trotterStepSize` modificando a duração da simulação em cada exponencial e `trotterOrder` para a ordem do integrador desejado.</span><span class="sxs-lookup"><span data-stu-id="b6d79-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: SimulationAlgorithm {
    ...
}

function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize : Double, 
    trotterOrder : Int) 
: TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="b6d79-156">Os aplicativos da biblioteca de simulação são abordados nos exemplos.</span><span class="sxs-lookup"><span data-stu-id="b6d79-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="b6d79-157">Para estimativa de fase no modelo Ising usando `SimulationAlgorithm`, consulte o exemplo [ **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="b6d79-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="b6d79-158">Para a preparação do estado adiabatic no modelo Ising usando `TimeDependentSimulationAlgorithm`, consulte o [exemplo **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="b6d79-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="b6d79-159">Estimativa de estado de adiabatic de & fase de preparação</span><span class="sxs-lookup"><span data-stu-id="b6d79-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="b6d79-160">Um aplicativo comum de simulação de Hamiltonian é a preparação do estado adiabatic.</span><span class="sxs-lookup"><span data-stu-id="b6d79-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="b6d79-161">Aqui, um é fornecido com dois Hamiltonians $H\_{\Text{Start}} $ e $H\_{\Text{end}} $ e um estado Quantum $ \ket{\psi (0)} $ que é um estado de aterramento da Hamiltonian $H\_{\Text{Start}} $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="b6d79-162">Normalmente, $H\_{\Text{Start}} $ é escolhido de modo que $ \ket{\psi (0)} $ seja fácil de se preparar de um estado de base computacional $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="b6d79-163">Ao fazer a interpolação entre esses Hamiltonians no problema de simulação dependente de tempo de forma suficientemente lenta, é possível terminar, com alta probabilidade, em um estado de terra do Hamiltonian final $H\_{\Text{end}} $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="b6d79-164">Embora a preparação de uma boa aproximação para os Estados de aterramento Hamiltonian possa continuar dessa maneira chamando os algoritmos de simulação de Hamiltonian dependentes de tempo como uma sub-rotina, outras abordagens conceitualmente diferentes, como a Quantum de variação eigensolver são possíveis.</span><span class="sxs-lookup"><span data-stu-id="b6d79-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="b6d79-165">Outro aplicativo onipresente no quantum química é estimar a energia de estado do solo de Hamiltonians que representa as etapas intermediárias da reação química.</span><span class="sxs-lookup"><span data-stu-id="b6d79-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="b6d79-166">Tal esquema poderia, por exemplo, contar com a preparação do estado adiabatic para criar o estado do solo e, em seguida, incorporar a simulação de Hamiltonian de tempo independente como uma sub-rotina na caracterização da estimativa de fase para extrair essa energia com um erro finito e probabilidade de sucesso.</span><span class="sxs-lookup"><span data-stu-id="b6d79-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="b6d79-167">Abstrair algoritmos de simulação como os tipos definidos pelo usuário `SimulationAlgorithm` e `TimeDependentSimulationAlgorithm` nos permite incorporar convenientemente sua funcionalidade a algoritmos Quantum mais sofisticados.</span><span class="sxs-lookup"><span data-stu-id="b6d79-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="b6d79-168">Isso nos motiva a fazer o mesmo para essas sub-rotinas usadas com frequência.</span><span class="sxs-lookup"><span data-stu-id="b6d79-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="b6d79-169">Portanto, definimos a função conveniente</span><span class="sxs-lookup"><span data-stu-id="b6d79-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime : Double, 
        evolutionGeneratorStart : EvolutionGenerator,
        evolutionGeneratorEnd : EvolutionGenerator,
        timeDependentSimulationAlgorithm : TimeDependentSimulationAlgorithm)
: (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="b6d79-170">Isso retorna uma operação unitário que implementa todas as etapas da preparação do estado adiabatic.</span><span class="sxs-lookup"><span data-stu-id="b6d79-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="b6d79-171">O primeiro parâmetro `interpolatedTime` define o tempo sobre o qual interpolar linearmente entre o Hamiltonian inicial descrito pelo segundo parâmetro `evolutionGeneratorStart` e o final Hamiltonian descrito pelo terceiro parâmetro `evolutionGeneratorEnd`.</span><span class="sxs-lookup"><span data-stu-id="b6d79-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="b6d79-172">O quarto parâmetro `timeDependentSimulationAlgorithm` é onde um faz a escolha do algoritmo de simulação.</span><span class="sxs-lookup"><span data-stu-id="b6d79-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="b6d79-173">Observe que, se `interpolatedTime` for longa o suficiente, um estado inicial de terra permanecerá um estado de aterramento instantâneo da Hamiltonian durante toda a duração da simulação dependente de tempo e, portanto, terminará no estado de terra do Hamiltonian final.</span><span class="sxs-lookup"><span data-stu-id="b6d79-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="b6d79-174">Também definimos uma operação útil que executa automaticamente todas as etapas de um experimento típico de química da Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="b6d79-175">Por exemplo, temos o seguinte, que retorna uma estimativa de energia do estado produzido pela preparação do estado adiabatic:</span><span class="sxs-lookup"><span data-stu-id="b6d79-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation EstimateAdiabaticStateEnergy(
    nQubits : Int,
    statePrepUnitary : (Qubit[] => Unit),
    adiabaticUnitary : (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double {
...
}
```

<span data-ttu-id="b6d79-176">`nQubits` é o número de qubits usado para codificar o estado inicial do Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="b6d79-177">`statePrepUnitary` prepara o estado de início da base computacional $ \ket{0\cdots 0} $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="b6d79-178">`adiabaticUnitary` é a operação unitário que implementa a preparação do estado adiabatic, como produzida pela função `InterpolatedEvolution`.</span><span class="sxs-lookup"><span data-stu-id="b6d79-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="b6d79-179">`qpeUnitary` é a operação unitário que é usada para executar a estimativa de fase no estado resultante do Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="b6d79-180">`phaseEstAlgorithm` é nossa escolha de algoritmo de estimativa de fase.</span><span class="sxs-lookup"><span data-stu-id="b6d79-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="b6d79-181">Os aplicativos da preparação do estado adiabatic são abordados nos exemplos.</span><span class="sxs-lookup"><span data-stu-id="b6d79-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="b6d79-182">Para o modelo Ising usando uma implementação manual da preparação do estado adiabatic versus usando a função `AdiabaticEvolution`, consulte o [exemplo **AdiabaticIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span><span class="sxs-lookup"><span data-stu-id="b6d79-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="b6d79-183">Para estimativa de fase e preparação do estado adiabatic no modelo Ising, consulte o [exemplo **IsingPhaseEstimation** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span><span class="sxs-lookup"><span data-stu-id="b6d79-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="b6d79-184">A [simulação de molecular Hydrogen](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) é uma amostra interessante e breve.</span><span class="sxs-lookup"><span data-stu-id="b6d79-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="b6d79-185">O modelo e os resultados experimentais relatados em [' Malley et. al.](https://arxiv.org/abs/1512.06860)</span><span class="sxs-lookup"><span data-stu-id="b6d79-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="b6d79-186">requer apenas matrizes Pauli e usa a forma $ \hat H = g\_{0}I\_0I\_1 + g\_1 {Z\_0} + g\_2 {Z\_1} + g\_3 {Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="b6d79-187">Esse é um Hamiltonian efetivo que só exige apenas 2 qubits, em que as constantes $g $ são computadas a partir da distância $R $ entre os dois Atoms Hydrogen.</span><span class="sxs-lookup"><span data-stu-id="b6d79-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="b6d79-188">Usando as funções do Canon, os Paul são convertidos em unidades e, em seguida, evoluíram por curtos períodos de tempo usando a decomposição Trotter-Suzuki.</span><span class="sxs-lookup"><span data-stu-id="b6d79-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="b6d79-189">Uma boa aproximação para o estado de terra $H _2 $ pode ser criada sem usar a preparação do estado adiabatic e, portanto, a energia do estado terrestre pode ser encontrada diretamente usando a estimativa de fase da Canon.</span><span class="sxs-lookup"><span data-stu-id="b6d79-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="b6d79-190">Algoritmo de Shor</span><span class="sxs-lookup"><span data-stu-id="b6d79-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="b6d79-191">O algoritmo do Atal continua sendo um dos desenvolvimentos mais significativos na computação Quantum, pois ele mostrou que os computadores Quantum podem ser usados para resolver problemas importantes e, no momento, inmanejáveis.</span><span class="sxs-lookup"><span data-stu-id="b6d79-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="b6d79-192">O algoritmo do Atal fornece uma maneira rápida de fatorar números grandes usando um computador Quantum, um problema chamado de *fatoração*.</span><span class="sxs-lookup"><span data-stu-id="b6d79-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="b6d79-193">A segurança de muitos cryptosystems de hoje é baseada na suposição de que não existe um algoritmo rápido para fatoração.</span><span class="sxs-lookup"><span data-stu-id="b6d79-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="b6d79-194">Portanto, o algoritmo de Atal teve um impacto profundo em como pensamos na segurança em um mundo posterior.</span><span class="sxs-lookup"><span data-stu-id="b6d79-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="b6d79-195">O algoritmo do Atal pode ser considerado como um algoritmo híbrido.</span><span class="sxs-lookup"><span data-stu-id="b6d79-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="b6d79-196">O computador Quantum é usado para executar uma tarefa de computação física conhecida como descoberta de períodos.</span><span class="sxs-lookup"><span data-stu-id="b6d79-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="b6d79-197">Os resultados da localização do período são então processados de uma estimativa para estimar os fatores.</span><span class="sxs-lookup"><span data-stu-id="b6d79-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="b6d79-198">Examinamos essas duas etapas abaixo.</span><span class="sxs-lookup"><span data-stu-id="b6d79-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="b6d79-199">Localização do período</span><span class="sxs-lookup"><span data-stu-id="b6d79-199">Period Finding</span></span> ###

<span data-ttu-id="b6d79-200">Depois de ver como o trabalho de transformação de Fourier de Quantum e a estimativa de fase (consulte [algoritmos de Quantum](xref:microsoft.quantum.libraries.standard.algorithms)), podemos usar essas ferramentas para resolver um problema computacional de forma clássica, chamado *localização de períodos*.</span><span class="sxs-lookup"><span data-stu-id="b6d79-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="b6d79-201">Na próxima seção, veremos como aplicar a localização do período à fatoração.</span><span class="sxs-lookup"><span data-stu-id="b6d79-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="b6d79-202">Considerando dois inteiros $a $ e $N $, em que $a < N $, a meta do período que localiza, também chamada de Order Localization, é encontrar a _ordem_ $r $ of $a $ módulo $N $, em que $r $ é definido para ser o inteiro mínimo positivo, de forma que $a ^ r \equiv 1 \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="b6d79-203">Para localizar o pedido usando um computador Quantum, podemos usar o algoritmo estimativa de fase aplicado ao operador unitário a seguir $U _a $: $ $ U_a \ket{x} \equiv \ket{(AX) \Text{mod} N}. $ $ eigenvectors de $U _a $ são para Integer $s $ e $0 \ Leq s \leq r-$1, $ $ \ket{x_s} \equiv 1/\sqrt{r} \sum\_{k = 0} ^ {r-1} e ^ {\frac{-2\pi i SK} {r}} \ket{a ^ k\text {mod} N}, $ $ são _eigenstates_ de $U _A $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="b6d79-204">O eigenvalues de $U _a $ $ U\_um \ket{x\_s} = e ^ {2 \ Pi i s/r} \ket{x\_s}.</span><span class="sxs-lookup"><span data-stu-id="b6d79-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="b6d79-205">A estimativa de fase gera, portanto, o eigenvalues $e ^ {2 \ Pi i s/r} $, do qual $r $ pode ser aprendido com eficiência usando as [frações contínuas](https://en.wikipedia.org/wiki/Continued_fraction) de $s/r $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="b6d79-206">O diagrama de circuito para localização do período Quantum é:</span><span class="sxs-lookup"><span data-stu-id="b6d79-206">The circuit diagram for quantum period finding is:</span></span>

![](./../../media/QPE.svg)

<span data-ttu-id="b6d79-207">Aqui, $2n $ qubits são inicializados para $ \ket{0}$ e $n $ qubits são inicializados para $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="b6d79-207">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="b6d79-208">O leitor pode imaginar novamente por que o Quantum Register para manter o eigenstates é inicializado para $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="b6d79-208">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="b6d79-209">Como não sabemos a ordem $r $ antecipadamente, não podemos realmente preparar $ \ket{x_s} $ States diretamente.</span><span class="sxs-lookup"><span data-stu-id="b6d79-209">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="b6d79-210">Felizmente, acontece que $1/\ sqrt {r} \sum\_{s = 0} ^ {r-1} \ket{x\_s} = \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="b6d79-210">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="b6d79-211">Não precisamos realmente preparar $ \ket{x} $!</span><span class="sxs-lookup"><span data-stu-id="b6d79-211">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="b6d79-212">Podemos apenas preparar um registro Quantum de $n $ qubits no estado $ \ket{1}$.</span><span class="sxs-lookup"><span data-stu-id="b6d79-212">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="b6d79-213">O circuito contém o QFT e vários Gates controlados.</span><span class="sxs-lookup"><span data-stu-id="b6d79-213">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="b6d79-214">O portão QFT foi descrito [anteriormente](xref:microsoft.quantum.libraries.standard.algorithms).</span><span class="sxs-lookup"><span data-stu-id="b6d79-214">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="b6d79-215">O $U controlado _a Gate mapeia $ \ket{x} $ para $ \ket{(AX) \Text{mod} N} $ se o controle qubit for $ \ket{1}$ e mapear $ \ket{x} $ para $ \ket{x} $ caso contrário.</span><span class="sxs-lookup"><span data-stu-id="b6d79-215">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="b6d79-216">Para atingir $ (a ^ NX) \Text{mod} N $, podemos simplesmente aplicar controlled-$U _ {a ^ N} $, em que calculamos $a ^ N \Text{mod} N $ de forma clássica para conectar-se ao circuito Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6d79-216">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="b6d79-217">Os circuitos para atingir esse tipo de aritmética de modulação foram descritos na [documentação aritmética do Quantum](./algorithms.md#arithmetic), especificamente exigimos um circuito de exponenciação modular para implementar as operações de $U controlado\_{a ^ i} $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-217">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="b6d79-218">Enquanto o circuito acima corresponde à [estimativa da fase Quantum](xref:microsoft.quantum.characterization.quantumphaseestimation) e habilita explicitamente a localização da ordem, podemos reduzir o número de qubits necessário.</span><span class="sxs-lookup"><span data-stu-id="b6d79-218">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="b6d79-219">Podemos seguir o método de Beauregard para a localização de pedidos, conforme descrito [na página 8 de arXiv: Quant-pH/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), ou use uma das rotinas de estimativa de fase disponível em Microsoft. Quantum. caracterization.</span><span class="sxs-lookup"><span data-stu-id="b6d79-219">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Characterization.</span></span> <span data-ttu-id="b6d79-220">Por exemplo, a [estimativa de fase robusta](xref:microsoft.quantum.characterization.robustphaseestimation) também usa um qubit extra.</span><span class="sxs-lookup"><span data-stu-id="b6d79-220">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="b6d79-221">Cálculo</span><span class="sxs-lookup"><span data-stu-id="b6d79-221">Factoring</span></span> ###
<span data-ttu-id="b6d79-222">A meta de fatoração é determinar os dois fatores primos de Integer $N $, em que $N $ é um número de $n $-bit.</span><span class="sxs-lookup"><span data-stu-id="b6d79-222">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="b6d79-223">A fatoração consiste nas etapas descritas abaixo.</span><span class="sxs-lookup"><span data-stu-id="b6d79-223">Factoring consists of the steps described below.</span></span> <span data-ttu-id="b6d79-224">As etapas são divididas em três partes: uma rotina de pré-processamento clássica (1-4); uma rotina de computação Quantum para localizar a ordem de $a \Text{mod} N $ (5); e uma rotina de pré-processamento clássica para derivar os fatores primos da ordem (6-9).</span><span class="sxs-lookup"><span data-stu-id="b6d79-224">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="b6d79-225">A rotina de pré-processamento clássica consiste nas seguintes etapas:</span><span class="sxs-lookup"><span data-stu-id="b6d79-225">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="b6d79-226">Se $N $ for par, retorne o fator principal $2 $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-226">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="b6d79-227">Se $N = p ^ q $ para $p \geq1 $, $q \geq2 $, retorne o fator principal $p $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-227">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="b6d79-228">Esta etapa é executada de clássico.</span><span class="sxs-lookup"><span data-stu-id="b6d79-228">This step is performed classically.</span></span>
3. <span data-ttu-id="b6d79-229">Escolha um número aleatório $a $ de $1 < um < N-$1.</span><span class="sxs-lookup"><span data-stu-id="b6d79-229">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="b6d79-230">Se $ \Text{GCD} (a, N) > 1 $, retorne o fator principal $ \Text{GCD} (a, N) $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-230">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="b6d79-231">Esta etapa é calculada usando o algoritmo do Euclid.</span><span class="sxs-lookup"><span data-stu-id="b6d79-231">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="b6d79-232">Se nenhum fator principal tiver sido retornado, continuamos para a rotina Quantum:</span><span class="sxs-lookup"><span data-stu-id="b6d79-232">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="b6d79-233">Chame o algoritmo do período Quantum que localiza para calcular a ordem $r $ de $a \Text{mod} N $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-233">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="b6d79-234">Use $r $ na rotina de pré-processamento clássica para determinar os principais fatores:</span><span class="sxs-lookup"><span data-stu-id="b6d79-234">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="b6d79-235">Se $r $ for ímpar, volte para a etapa de pré-processamento (3).</span><span class="sxs-lookup"><span data-stu-id="b6d79-235">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="b6d79-236">Se $r $ for par e $a ^ {r/2} =-1 \ Text {mod} N $, volte para a etapa de pré-processamento (3).</span><span class="sxs-lookup"><span data-stu-id="b6d79-236">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="b6d79-237">Se $ \Text{GCD} (a ^ {r/2} + 1, N) $ for um fator não trivial de $N $, retorne $ \Text{GCD} (um ^ {r/2} + 1, N) $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-237">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="b6d79-238">Se $ \Text{GCD} (a ^ {r/2}-1, N) $ for um fator não trivial de $N $, retorne $ \Text{GCD} (um ^ {r/2}-1, N) $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-238">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="b6d79-239">O algoritmo de fatoração é probabilística: pode ser mostrado que, com probabilidade, pelo menos uma metade que $r $ será par e $a ^ {r/2} \neq-1 \Text{mod} N $, produzindo assim um fator primo.</span><span class="sxs-lookup"><span data-stu-id="b6d79-239">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="b6d79-240">(Consulte o [artigo original do Atal](https://doi.org/10.1109/SFCS.1994.365700) para obter detalhes ou um dos textos *básicos de computação Quantum* no para obter [mais informações](xref:microsoft.quantum.more-information)).</span><span class="sxs-lookup"><span data-stu-id="b6d79-240">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="b6d79-241">Se um fator principal não for retornado, basta repetir o algoritmo da etapa (1).</span><span class="sxs-lookup"><span data-stu-id="b6d79-241">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="b6d79-242">Após $n $ tentativas, a probabilidade de que cada tentativa tenha falha é no máximo $2 ^ {-n} $.</span><span class="sxs-lookup"><span data-stu-id="b6d79-242">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="b6d79-243">Assim, depois de repetir o algoritmo, um número pequeno de vezes o sucesso é praticamente garantido.</span><span class="sxs-lookup"><span data-stu-id="b6d79-243">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
