---
title: 'Q # bibliotecas padrão-caracterização | Microsoft Docs'
description: 'P # bibliotecas padrão-caracterização'
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 51124dc78feedf6d5c85fe224898e66a1c5ed459
ms.sourcegitcommit: ca5015fed409eaf0395a89c2e4bc6a890c360aa2
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/29/2020
ms.locfileid: "76870341"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="94a61-103">Caracterização e estatísticas do Quantum</span><span class="sxs-lookup"><span data-stu-id="94a61-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="94a61-104">É fundamental poder caracterizar os efeitos das operações para desenvolver algoritmos de Quantum úteis.</span><span class="sxs-lookup"><span data-stu-id="94a61-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="94a61-105">Isso é desafiador porque cada medição de um sistema Quantum gera no máximo um pouco de informação.</span><span class="sxs-lookup"><span data-stu-id="94a61-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="94a61-106">Para aprender um eigenvalue, independente de um estado Quantum, os resultados de várias medições devem ser Unidos para que o usuário possa obter as muitas informações necessárias para representar esses conceitos.</span><span class="sxs-lookup"><span data-stu-id="94a61-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="94a61-107">Os Estados da Quantum são especialmente inconvenientes porque o [teorema sem clonagem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) afirma que não há como aprender um estado de Quantum arbitrário a partir de uma única cópia do estado, pois isso permitiria que você faça cópias do estado.</span><span class="sxs-lookup"><span data-stu-id="94a61-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="94a61-108">Essa ofuscação do estado Quantum do usuário é refletida no fato de que Q # não expõe ou nem define o que um estado *é* para os programas Quantum.</span><span class="sxs-lookup"><span data-stu-id="94a61-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="94a61-109">Portanto, abordamos a caracterização Quantum tratando as operações e os Estados como preto-caixa; Essa abordagem compartilha muito em comum com a prática experimental de caracterização, verificação e validação do Quantum (QCVV).</span><span class="sxs-lookup"><span data-stu-id="94a61-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="94a61-110">A caracterização é distinta de muitas das outras bibliotecas discutidas anteriormente.</span><span class="sxs-lookup"><span data-stu-id="94a61-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="94a61-111">O objetivo aqui é menos aprender informações clássicas sobre o sistema, em vez de executar uma transformação unitário em um vetor de estado.</span><span class="sxs-lookup"><span data-stu-id="94a61-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="94a61-112">Portanto, essas bibliotecas devem misturar o processamento de informações clássica e Quantum.</span><span class="sxs-lookup"><span data-stu-id="94a61-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="94a61-113">Estimativa de fase iterativa</span><span class="sxs-lookup"><span data-stu-id="94a61-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="94a61-114">A exibição da programação Quantum em termos de caracterização Quantum sugere uma alternativa útil à estimativa da fase Quantum.</span><span class="sxs-lookup"><span data-stu-id="94a61-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="94a61-115">Ou seja, em vez de preparar um registro de $n $-qubit para conter uma representação binária da fase como na estimativa da fase Quantum, podemos exibir a estimativa de fase como o processo pelo qual um agente *clássico* aprende as propriedades de um sistema Quantum por meio de medidas.</span><span class="sxs-lookup"><span data-stu-id="94a61-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="94a61-116">Continuaremos como no caso do Quantum usando a fase Kickback para transformar os aplicativos de uma operação de caixa preta em rotações por um ângulo desconhecido, mas medirá o qubit de ancilla que giramos em cada etapa imediatamente após a rotação.</span><span class="sxs-lookup"><span data-stu-id="94a61-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="94a61-117">Isso tem a vantagem de exigirmos apenas um único qubit adicional para executar a fase Kickback descrita no caso Quantum, como aprendemos a fase dos resultados da medida em cada etapa de maneira iterativa.</span><span class="sxs-lookup"><span data-stu-id="94a61-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="94a61-118">Cada um dos métodos propostos abaixo usa uma estratégia diferente para a criação de experimentos e métodos de processamento de dados diferentes para aprender a fase.</span><span class="sxs-lookup"><span data-stu-id="94a61-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="94a61-119">Cada um deles tem vantagem única, desde a necessidade de limites de erro rigorosos até a capacidade de incorporar informações anteriores, tolerar erros ou executar em computadores Limitted de memória.</span><span class="sxs-lookup"><span data-stu-id="94a61-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="94a61-120">Ao discutir a estimativa de fase iterativa, consideraremos um $U unitário $ fornecido como uma operação de caixa preta.</span><span class="sxs-lookup"><span data-stu-id="94a61-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="94a61-121">Conforme descrito na seção sobre Oracle em estruturas de [dados](xref:microsoft.quantum.libraries.data-structures), os modelos Q # Canon são operações pelo tipo de <xref:microsoft.quantum.oracles.discreteoracle> definido pelo usuário, definido pelo `((Int, Qubit[]) => Unit : Adjoint, Controlled)`tipo de tupla.</span><span class="sxs-lookup"><span data-stu-id="94a61-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="94a61-122">Concretamente, se `U : DiscreteOracle`, `U(m)` implementa $U ^ m $ para `m : Int`.</span><span class="sxs-lookup"><span data-stu-id="94a61-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="94a61-123">Com essa definição em vigor, cada etapa da estimativa de fase iterativa continua preparando uma qubit auxiliar no estado $ \ket{+} $, juntamente com o estado inicial $ \ket{\phi} $ que supomos que é um [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) de $U (m) $, ou seja, $U (m) \ket{\phi} = e ^ {im\phi} \ ket {\ Phi} $.</span><span class="sxs-lookup"><span data-stu-id="94a61-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxiliary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="94a61-124">Um aplicativo controlado de `U(m)` é usado, o que prepara o estado $ \left (R\_1 (m \phi) \ket{+} \right) \ket{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="94a61-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="94a61-125">Como no caso do Quantum, o efeito de um aplicativo controlado do `U(m)` da Oracle é precisamente o mesmo que o efeito de aplicar $R _1 $ para a fase desconhecida em $ \ket{+} $, de modo que possamos descrever os efeitos de $U $ dessa maneira mais simples.</span><span class="sxs-lookup"><span data-stu-id="94a61-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="94a61-126">Opcionalmente, o algoritmo gira o controle qubit aplicando $R _1 (-m\theta) $ para obter um estado $ \ket{\psi} = \left (R\_1 (m [\phi-\theta]) \ket{+} \right) \ket{\phi} $ $.</span><span class="sxs-lookup"><span data-stu-id="94a61-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="94a61-127">O qubit auxiliar usado como um controle para `U(m)` é então medido na base $X $ para obter um único `Result`clássico.</span><span class="sxs-lookup"><span data-stu-id="94a61-127">The auxiliary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="94a61-128">Neste ponto, a reconstrução da fase do `Result` valores obtidos por meio da estimativa de fase iterativa é um problema de inferência de estatística clássica.</span><span class="sxs-lookup"><span data-stu-id="94a61-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="94a61-129">Encontrar o valor de $m $ que maximiza as informações obtidas, considerando um método de inferência fixo, é simplesmente um problema nas estatísticas.</span><span class="sxs-lookup"><span data-stu-id="94a61-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="94a61-130">Enfatizamos isso descrevendo brevemente a estimativa de fase iterativa em um nível teórico no bayesiana de estimativa de parâmetro de subestimação antes de continuar a descrever os algoritmos estatísticos fornecidos no Q # Canon para resolver esse problema de inferência clássica.</span><span class="sxs-lookup"><span data-stu-id="94a61-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="94a61-131">Estimativa de fase iterativa sem Eigenstates</span><span class="sxs-lookup"><span data-stu-id="94a61-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="94a61-132">Se um estado de entrada for fornecido que não é um eigenstate, o que significa que, se $U (m) \ket{\phi\_j} = e ^ {im\phi\_j} $, o processo de estimativa de fase não determina de forma determinística o estado da Quantum em direção a um único eigenstate de energia.</span><span class="sxs-lookup"><span data-stu-id="94a61-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="94a61-133">A eigenstate, na verdade, convergi que é a eigenstate que tem mais probabilidade de produzir os `Result`observados.</span><span class="sxs-lookup"><span data-stu-id="94a61-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="94a61-134">Especificamente, uma única etapa do PE executa a seguinte transformação não-unitário em um estado \begin{align} \ sum_j \sqrt{\Pr (\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac {\ sqrt {\ PR (\phi\_j)} \sqrt{\Pr (\text{Result} | \phi\_j)} \ket{\phi\_j}} {\sqrt{\Pr (\phi\_j) \sum\_j \Pr (\text{Result} | \phi\_j)}}.</span><span class="sxs-lookup"><span data-stu-id="94a61-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="94a61-135">\end{align} como esse processo é iterado em vários valores de `Result`, eigenstates que não têm valores máximos de $ \ prod_k \Pr (\text{Result}\_k | \phi\_j) $ serão suprimidos exponencialmente.</span><span class="sxs-lookup"><span data-stu-id="94a61-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="94a61-136">Como resultado, o processo de inferência terá a tendência de convergir para Estados com um único eigenvalue se os experimentos forem escolhidos corretamente.</span><span class="sxs-lookup"><span data-stu-id="94a61-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="94a61-137">Bayes ' teorema ' sugere mais que o estado resultante da estimativa de fase seja gravado no formato \begin{align} \frac{\sqrt{\Pr (\phi\_j)} \sqrt{\Pr (\text{Result} | \phi\_j)} \ket{\phi\_j}} {\sqrt{\Pr (\phi\_j) \sum\_j \Pr (\text{Result} | \phi\_j)}} = \ sum_j \sqrt{\Pr (\phi\_j | \text{Result})} \ket{\phi\_j}.</span><span class="sxs-lookup"><span data-stu-id="94a61-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="94a61-138">\end{align} aqui $ \Pr (\phi\_j | \text{Result}) $ pode ser interpretado como a probabilidade de que um ascribeia para cada hipótese sobre os eigenstates fornecidos:</span><span class="sxs-lookup"><span data-stu-id="94a61-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="94a61-139">conhecimento do estado do Quantum antes da medição,</span><span class="sxs-lookup"><span data-stu-id="94a61-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="94a61-140">conhecimento do eigenstates de $U $ e,</span><span class="sxs-lookup"><span data-stu-id="94a61-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="94a61-141">conhecimento do eigenvalues de $U $.</span><span class="sxs-lookup"><span data-stu-id="94a61-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="94a61-142">Aprender essas três coisas muitas vezes é exponencialmente difícil em um computador clássico.</span><span class="sxs-lookup"><span data-stu-id="94a61-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="94a61-143">O utilitário de estimativa de fase surge, sem qualquer extensão, desde o fato de que ele pode executar tal tarefa de aprendizado Quantum sem conhecer nenhum deles.</span><span class="sxs-lookup"><span data-stu-id="94a61-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="94a61-144">A estimativa de fase para esse motivo aparece dentro de um número de algoritmos Quantum que fornecem aumentos exponencials.</span><span class="sxs-lookup"><span data-stu-id="94a61-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="94a61-145">Estimativa de fase Bayesiana</span><span class="sxs-lookup"><span data-stu-id="94a61-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="94a61-146">Para obter mais detalhes sobre a estimativa de fase Bayesiana na prática, consulte o exemplo de [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) .</span><span class="sxs-lookup"><span data-stu-id="94a61-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="94a61-147">A ideia da estimativa de fase de bayesiana é simples.</span><span class="sxs-lookup"><span data-stu-id="94a61-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="94a61-148">Você coleta estatísticas de medição do protocolo de estimativa de fase e, em seguida, processa os resultados usando a inferência Bayesiana e fornece uma estimativa do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="94a61-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="94a61-149">Esse processamento fornece uma estimativa do eigenvalue, bem como a incerteza nessa estimativa.</span><span class="sxs-lookup"><span data-stu-id="94a61-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="94a61-150">Ele também permite que você execute experimentos adaptáveis e utilize informações anteriores.</span><span class="sxs-lookup"><span data-stu-id="94a61-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="94a61-151">A desvantagem do princípio dos métodos é que ele é computacionalmente exigente.</span><span class="sxs-lookup"><span data-stu-id="94a61-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="94a61-152">Para entender como esse processo de inferência de Bayesiana funciona, considere o caso de processamento de um único resultado de `Zero`.</span><span class="sxs-lookup"><span data-stu-id="94a61-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="94a61-153">Observe que $X = \ket{+} \bra{+}-\ket{-}\bra{-}$, de modo que $ \ket{+} $ é o único eigenstate positivo de $X $ correspondente a `Zero`.</span><span class="sxs-lookup"><span data-stu-id="94a61-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="94a61-154">A probabilidade de observar `Zero` para uma [medida`PauliX`](xref:microsoft.quantum.concepts.pauli) no primeiro qubit dado um estado de entrada $ \ket{\psi}\ket{\phi} $ é, portanto, \begin{Equation} \Pr (\texttt{zero} | \psi) = \left | \braket{+ | \psi} \right | ^ 2.</span><span class="sxs-lookup"><span data-stu-id="94a61-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="94a61-155">\end{Equation} no caso de estimativa de fase iterativa, temos o $ \ket{\psi} = R_1 (m [\phi-\theta]) \ket{+} $, de forma que \begin{align} \Pr (\texttt{Zero} | \phi; m, \theta) & = \left | \braket{+ | R_1 (m [\phi-\theta]) | +} \right | ^ 2 \\\\ & = \left | \frac12 \left (\bra{0} + \bra{1} \right) \left (\ket{0} + e ^ {i m [\phi-\theta]} \ket{1} \right) \right | ^ 2 \\\\ & = \left | \frac{1 + e ^ {i m [\phi-\theta]}}{2} \right | ^ 2 \\\\ & = \cos ^ 2 (m [\phi-\theta]/2) \tag{★} \label{EQ: Phase-est-probabilidade}.</span><span class="sxs-lookup"><span data-stu-id="94a61-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="94a61-156">\end{Align}, ou seja, a estimativa de fase iterativa consiste em aprender a frequência de oscilação de uma função sinusoidal, dada a capacidade de virar uma moeda com uma tendência dada por essa sinusoid.</span><span class="sxs-lookup"><span data-stu-id="94a61-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="94a61-157">Seguindo a terminologia clássica tradicional, chamamos de $ \eqref{EQ: Phase-est-probabilidade} $ a *função de probabilidade* para estimativa de fase iterativa.</span><span class="sxs-lookup"><span data-stu-id="94a61-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="94a61-158">Após observar uma `Result` da função de probabilidade de estimativa de fase iterativa, podemos usar a regra Bayes ' para prescrever o que deve acreditar que a fase esteja seguindo essa observação.</span><span class="sxs-lookup"><span data-stu-id="94a61-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="94a61-159">Concretamente, \begin{Equation} \Pr (\phi | d) = \frac{\Pr (d | \phi) \Pr (\phi)} {\int \Pr (d | \phi) \Pr (\phi) {\mathrm d} \phi} \Pr (\phi), \end{Equation} em que $d na \\{\texttt{Zero}, \texttt{One}\\} $ é um `Result`e, em que $ \Pr (\phi) $ descreve nossos crenças anteriores sobre $ \phi $.</span><span class="sxs-lookup"><span data-stu-id="94a61-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="94a61-160">Isso faz com que a natureza iterativa da estimativa de fase iterativa seja explícita, já que a distribuição posteriores $ \Pr (\phi | d) $ descreve nosso crenças imediatamente antes da nossa observação do próximo `Result`.</span><span class="sxs-lookup"><span data-stu-id="94a61-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceeding our observation of the next `Result`.</span></span>

<span data-ttu-id="94a61-161">A qualquer momento durante esse procedimento, podemos relatar a fase $ \hat{\phi} $ inferida pelo controlador clássico como \begin{Equation} \hat{\phi} \mathrel{: =} \expect [\phi | \Text{data}] = \int \phi \Pr (\phi | \Text{Data}) {\mathrm d} \phi, \end{Equation}, em que $ \Text{data} $ significa todo o registro de todos os `Result` valores obtidos.</span><span class="sxs-lookup"><span data-stu-id="94a61-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="94a61-162">A inferência exata de bayesiana é uma prática inmanejável.</span><span class="sxs-lookup"><span data-stu-id="94a61-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="94a61-163">Para ver essa imagine, desejamos aprender uma variável de $n de $ bits $x $.</span><span class="sxs-lookup"><span data-stu-id="94a61-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="94a61-164">A distribuição anterior $ \Pr (x) $ tem suporte acima de US $2 ^ n $ valores hipotéticos de $x $.</span><span class="sxs-lookup"><span data-stu-id="94a61-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="94a61-165">Isso significa que, se precisar de uma estimativa altamente precisa de $x $, a estimativa de fase Bayesiana poderá precisar de memória proibitiva e tempo de processamento.</span><span class="sxs-lookup"><span data-stu-id="94a61-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="94a61-166">Embora, para alguns aplicativos, como a simulação do Quantum, a precisão Limitted necessária não impede que outros métodos de outros aplicativos, como o algoritmo do Atal, não possam usar a inferência exata de Bayesiana em sua etapa de estimativa de fase.</span><span class="sxs-lookup"><span data-stu-id="94a61-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="94a61-167">Por esse motivo, também fornecemos implementações para métodos Bayesiana aproximados, como [estimativa aleatória de fase de passeio (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) e também abordagens não Bayesiana, como [estimativa de fase robusta](xref:microsoft.quantum.characterization.robustphaseestimation).</span><span class="sxs-lookup"><span data-stu-id="94a61-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="94a61-168">Estimativa de fase robusta</span><span class="sxs-lookup"><span data-stu-id="94a61-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="94a61-169">Uma reconstrução máxima de *posteriori* bayesiana de uma fase estimada dos resultados da medição é exponencialmente difícil no pior caso.</span><span class="sxs-lookup"><span data-stu-id="94a61-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="94a61-170">Assim, os algoritmos de estimativa de fase mais práticos sacrificam alguma qualidade na reconstrução, no Exchange para uma quantidade de pós-processamento clássico que, em vez disso, escala polinomialmente com o número de medições feitas.</span><span class="sxs-lookup"><span data-stu-id="94a61-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="94a61-171">Um exemplo com uma etapa de pós-processamento clássica eficiente é o algoritmo de [estimativa de fase robusta](https://arxiv.org/abs/1502.02677), com sua assinatura e suas entradas mencionadas acima.</span><span class="sxs-lookup"><span data-stu-id="94a61-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="94a61-172">Ele pressupõe que as caixas pretas de entrada $U $ são empacotadas como `DiscreteOracle` tipo e, portanto, consulta apenas as potências de inteiros de $U $ controlado $.</span><span class="sxs-lookup"><span data-stu-id="94a61-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="94a61-173">Se o estado de entrada no registro de `Qubit[]` for um eigenstate $U \ket{\psi} = e ^ {i\phi} \ ket {\ psi} $, o algoritmo de estimativa de fase robusta retornará uma estimativa $ \hat{\phi}\in [-\pi, \pi) $ de $ \phi $ como um `Double`.</span><span class="sxs-lookup"><span data-stu-id="94a61-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="94a61-174">O recurso mais importante da estimativa de fase robusta, que é compartilhada com a maioria das variantes úteis, é que a qualidade de reconstrução de $ \hat{\phi} $ está em certo sentido Heisenberg-Limited.</span><span class="sxs-lookup"><span data-stu-id="94a61-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="94a61-175">Isso significa que, se o desvio de $ \hat{\phi} $ do valor verdadeiro for $ \sigma $, $ \sigma $ escala inversamente – proporcionalmente ao número total de consultas $Q $ feitas para o $U controlado $, ou seja, $ \sigma = \mathcal{O} (1/Q) $.</span><span class="sxs-lookup"><span data-stu-id="94a61-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="94a61-176">Agora, a definição de desvio varia entre diferentes algoritmos de estimativa.</span><span class="sxs-lookup"><span data-stu-id="94a61-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="94a61-177">Em alguns casos, pode significar que, com pelo menos $ \mathcal{O} (1) $ probabilidade, o erro de estimativa $ | \hat{\phi}-\phi |\_\circ\le \sigma $ em alguma medida circular $ \circ $.</span><span class="sxs-lookup"><span data-stu-id="94a61-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="94a61-178">Para estimativa de fase robusta, o desvio é precisamente a variância $ \sigma ^ 2 = \mathbb{E}\_\hat{\phi} [(\mod\_{2 \ PI} (\hat{\phi}-\phi + \pi)-\pi) ^ 2] $ se não quebrarmos as fases periódicas em um único intervalo finito $ (-\pi, \pi] $.</span><span class="sxs-lookup"><span data-stu-id="94a61-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="94a61-179">Mais precisamente, o desvio padrão em estimativa de fase robusta satisfaz as desigualdades $ $ \begin{align} 2,0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ PI/Q, \end{Align} $ $, onde o limite inferior é atingido no limite de assintoticamente grande $Q $ e o limite superior é garantido até mesmo para tamanhos de amostra pequenos.</span><span class="sxs-lookup"><span data-stu-id="94a61-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="94a61-180">Observe que $n $ selecionado pela entrada de `bitsPrecision`, que define implicitamente $Q $.</span><span class="sxs-lookup"><span data-stu-id="94a61-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="94a61-181">Outros detalhes relevantes incluem, digamos, a sobrecarga de espaço pequeno de apenas $1 $ ancilla qubit, ou que o procedimento não é adaptável, o que significa que a sequência necessária de experimentos de Quantum é independente dos resultados de medida intermediários.</span><span class="sxs-lookup"><span data-stu-id="94a61-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="94a61-182">Neste e em breves exemplos em que a escolha do algoritmo de estimativa de fase é importante, deve-se consultar a documentação como @"microsoft.quantum.characterization.robustphaseestimation" e as publicações referenciadas aqui para obter mais informações e sobre sua implementação.</span><span class="sxs-lookup"><span data-stu-id="94a61-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.characterization.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="94a61-183">Há muitos exemplos em que a estimativa de fase robusta é usada.</span><span class="sxs-lookup"><span data-stu-id="94a61-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="94a61-184">Para estimativa de fase na extração da energia de estado terrestre de vários sistemas físicos, consulte o exemplo de [ **simulação H2** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), o [exemplo **SimpleIsing** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)e o exemplo de [ **modelo Hubbard** ](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span><span class="sxs-lookup"><span data-stu-id="94a61-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="94a61-185">Oracle contínuos</span><span class="sxs-lookup"><span data-stu-id="94a61-185">Continuous Oracles</span></span> ###

<span data-ttu-id="94a61-186">Também é possível generalizar a partir do modelo Oracle usado acima para permitir Oracle, modelados pelo tipo de Canon <xref:microsoft.quantum.oracles.continuousoracle>.</span><span class="sxs-lookup"><span data-stu-id="94a61-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="94a61-187">Considere que, em vez de um único operador unitário $U $, temos uma família de operadores unitários $U (t) $ para $t na \mathbb{R} $ de forma que $U (t) U (s) $ = $U (t + s) $.</span><span class="sxs-lookup"><span data-stu-id="94a61-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="94a61-188">Essa é uma declaração mais fraca do que no caso discreto, já que podemos construir uma <xref:microsoft.quantum.oracles.discreteoracle> restringindo $t = m\,\delta t $ para alguns $ \delta t $ fixos.</span><span class="sxs-lookup"><span data-stu-id="94a61-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="94a61-189">Por [teorema da pedra](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U (t) = \exp (i t) $ para algum operador $H $, em que $ \exp $ é o exponencial de matriz, conforme descrito em [matrizes avançadas](xref:microsoft.quantum.concepts.matrix-advanced).</span><span class="sxs-lookup"><span data-stu-id="94a61-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="94a61-190">Um eigenstate $ \ket{\phi} $ de $H $ de forma que $H \ket{\phi} = \phi \ket{\phi} $ também é um eigenstate de $U (t) $ para todos os $t $, \begin{Equation} U (t) \ket{\phi} = e ^ {i \phi t} \ket{\phi}.</span><span class="sxs-lookup"><span data-stu-id="94a61-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="94a61-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="94a61-191">\end{equation}</span></span>

<span data-ttu-id="94a61-192">A mesma análise discutida para a [estimativa de fase Bayesiana](#bayesian-phase-estimation) pode ser aplicada e a função de probabilidade é exatamente a mesma para esse modelo mais geral da Oracle: $ $ \Pr (\texttt{zero} | \phi; t, \theta) = \cos ^ 2 \ Left (\frac{t [\phi-\theta]}{2}\right).</span><span class="sxs-lookup"><span data-stu-id="94a61-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="94a61-193">$ $ Mais, se $U $ for uma simulação de um gerador dinâmico, como é o caso da [simulação de Hamiltonian](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), interpretamos $ \phi $ como uma energia.</span><span class="sxs-lookup"><span data-stu-id="94a61-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="94a61-194">Portanto, o uso da estimativa de fase com consultas contínuas nos permite aprender o espectro de energia simulado [de moléculas](https://arxiv.org/abs/quant-ph/0604193), [materiais](https://arxiv.org/abs/1510.03859) ou [campo teorias](https://arxiv.org/abs/1111.3633v2) sem precisar comprometer nossa escolha de experimentos exigindo $t $ para ser um inteiro.</span><span class="sxs-lookup"><span data-stu-id="94a61-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="94a61-195">Estimativa de fase de passo aleatório</span><span class="sxs-lookup"><span data-stu-id="94a61-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="94a61-196">O Q # fornece uma aproximação útil de estimativa de fase de Bayesiana projetada para uso próximo de dispositivos Quantum que operam por condicionado uma movimentação aleatória no registro de dados obtido da estimativa de fase iterativa.</span><span class="sxs-lookup"><span data-stu-id="94a61-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="94a61-197">Esse método é adaptativo e totalmente determinístico, permitindo o dimensionamento quase ideal de erros na fase estimada $ \hat{\phi} $ com sobrecargas de memória muito baixas.</span><span class="sxs-lookup"><span data-stu-id="94a61-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="94a61-198">O protocolo usa um método de inferência Bayesiana aproximado que assume que a distribuição anterior é gaussiana.</span><span class="sxs-lookup"><span data-stu-id="94a61-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="94a61-199">Essa suposição gaussiana nos permite usar uma fórmula analítica para o experimento que minimiza a variância de posteriores.</span><span class="sxs-lookup"><span data-stu-id="94a61-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="94a61-200">Em seguida, o algoritmo, com base no resultado desse experimento, muda a estimativa de $ \phi $ para a esquerda ou direita por uma quantidade predeterminada e reduz a variância por um valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="94a61-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="94a61-201">Essa média e variância fornecem todas as informações necessárias para especificar um gaussiano anterior em $ \phi $ para o próximo experimento.</span><span class="sxs-lookup"><span data-stu-id="94a61-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="94a61-202">Falhas de medição inesperadas ou o resultado real que está nas caudas do início anterior, pode causar a falha desse método.</span><span class="sxs-lookup"><span data-stu-id="94a61-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="94a61-203">Ele se recupera de uma falha executando experimentos para testar se a média atual e o desvio padrão são apropriados para o sistema.</span><span class="sxs-lookup"><span data-stu-id="94a61-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="94a61-204">Se não forem, o algoritmo fará uma etapa inversa da movimentação e o processo continuará.</span><span class="sxs-lookup"><span data-stu-id="94a61-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="94a61-205">A capacidade de avançar para trás também permite que o algoritmo Aprenda mesmo se o desvio padrão anterior inicial for inapropriately pequeno.</span><span class="sxs-lookup"><span data-stu-id="94a61-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="94a61-206">Chamando algoritmos de estimativa de fase</span><span class="sxs-lookup"><span data-stu-id="94a61-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="94a61-207">Cada operação de estimativa de fase fornecida com o Q # Canon usa um conjunto diferente de entradas parametrizando a qualidade que solicitamos a estimativa final de $ \hat{\phi} $.</span><span class="sxs-lookup"><span data-stu-id="94a61-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="94a61-208">No entanto, essas várias entradas compartilham várias entradas em comum, de modo que o aplicativo parcial nos parâmetros de qualidade resulta em uma assinatura comum.</span><span class="sxs-lookup"><span data-stu-id="94a61-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="94a61-209">Por exemplo, a operação de <xref:microsoft.quantum.characterization.robustphaseestimation> discutida na próxima seção tem a seguinte assinatura:</span><span class="sxs-lookup"><span data-stu-id="94a61-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="94a61-210">A entrada `bitsPrecision` é exclusiva para `RobustPhaseEstimation`, enquanto `oracle` e `eigenstate` estão em comum.</span><span class="sxs-lookup"><span data-stu-id="94a61-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="94a61-211">Assim, como visto no **H2Sample**, uma operação pode aceitar um algoritmo de estimativa de fase iterativa com uma entrada do formulário `(DiscreteOracle, Qubit[]) => Unit` para permitir que um usuário especifique algoritmos de estimativa de fase arbitrária:</span><span class="sxs-lookup"><span data-stu-id="94a61-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int,
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double))
: Double
```

<span data-ttu-id="94a61-212">Esses algoritmos de estimativa de inúmeras fases são otimizados para diferentes propriedades e parâmetros de entrada, que devem ser compreendidos para fazer a melhor escolha para o aplicativo de destino.</span><span class="sxs-lookup"><span data-stu-id="94a61-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="94a61-213">Por exemplo, alguns algoritmos de estimativa de fase são adaptáveis, o que significa que as etapas futuras são controladas de maneira clássica pelos resultados das medidas anteriores.</span><span class="sxs-lookup"><span data-stu-id="94a61-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="94a61-214">Alguns exigem a capacidade de exponentiater seu Oracle unitário de caixa preta com potências reais arbitrárias e outros exigem apenas potências de inteiros, mas só podem resolver um módulo de estimativa de fase $2 \ PI $.</span><span class="sxs-lookup"><span data-stu-id="94a61-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="94a61-215">Alguns exigem muitos qubits auxiliares e outros exigem apenas um.</span><span class="sxs-lookup"><span data-stu-id="94a61-215">Some require many auxiliary qubits, and others require only one.</span></span>

<span data-ttu-id="94a61-216">Da mesma forma, o uso da estimativa de fase de busca aleatória prossegue praticamente da mesma forma que para outros algoritmos fornecidos com a Canon:</span><span class="sxs-lookup"><span data-stu-id="94a61-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ApplyExampleOracle(
    eigenphase : Double,
    time : Double,
    register : Qubit[])
: Unit is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation EstimateBayesianPhase(eigenphase : Double) : Double {
    let oracle = ContinuousOracle(ApplyExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
