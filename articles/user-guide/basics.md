---
title: 'Q# Noções básicas'
description: 'Conceitos básicos do Q#'
author: gillenhaalb
ms.author: a-gibec
ms.date: 02/28/2020
ms.topic: article
uid: microsoft.quantum.guide.basics
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: b3bc0841eabeac5d3968776f9dab3a02b1a1eef9
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/27/2020
ms.locfileid: "92691631"
---
# <a name="no-locq-basics"></a><span data-ttu-id="cc63d-103">Q# Noções básicas</span><span class="sxs-lookup"><span data-stu-id="cc63d-103">Q# Basics</span></span>

<span data-ttu-id="cc63d-104">Este artigo apresenta uma breve introdução aos blocos de construção básicos do Q# .</span><span class="sxs-lookup"><span data-stu-id="cc63d-104">This article presents a brief introduction to the basic building blocks of Q#.</span></span>

<span data-ttu-id="cc63d-105">Para obter uma visão geral do que Q# é e onde ele se encaixa como um componente fundamental do kit de desenvolvimento Quantum, consulte [o que é Q# ?](xref:microsoft.quantum.overview.q-sharp).</span><span class="sxs-lookup"><span data-stu-id="cc63d-105">For an overview of what Q# is and where it fits in as a fundamental component of the Quantum Development Kit, see [What is Q#?](xref:microsoft.quantum.overview.q-sharp).</span></span> 

## <a name="what-is-a-quantum-program"></a><span data-ttu-id="cc63d-106">O que é um programa Quantum?</span><span class="sxs-lookup"><span data-stu-id="cc63d-106">What is a quantum program?</span></span>

<span data-ttu-id="cc63d-107">Do ponto de vista técnico, um programa Quantum é um conjunto específico de sub-rotinas clássicas que, quando chamados, executam determinadas operações em um sistema Quantum.</span><span class="sxs-lookup"><span data-stu-id="cc63d-107">From a technical perspective, a quantum program is a particular set of classical subroutines which, when called, perform certain operations on a quantum system.</span></span>
<span data-ttu-id="cc63d-108">Uma consequência importante dessa exibição é que um Q# programa não modele diretamente o qubits em si, mas descreve como um computador com controle clássico interage com esses qubits.</span><span class="sxs-lookup"><span data-stu-id="cc63d-108">An important consequence of that view is that a Q# program does not directly model qubits themselves, but rather describes how a classically controlled computer interacts with those qubits.</span></span>
<span data-ttu-id="cc63d-109">Por design, Q# o não define os Estados Quantum ou outras propriedades da mecânica quantum diretamente.</span><span class="sxs-lookup"><span data-stu-id="cc63d-109">By design, Q# does not define quantum states or other properties of quantum mechanics directly.</span></span>
<span data-ttu-id="cc63d-110">Por exemplo, considere o estado $ \ket{+} = \left (\ket {0} + \ket {1} \right)/\sqrt {2} $ discutido no guia de [conceitos da computação Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="cc63d-110">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="cc63d-111">Para preparar esse estado no Q# , comece com os fatos que os qubits são inicializados no estado $ \ket {0} $ e que $ \ket{+} = H\ket {0} $, em que $H $ é a [transformação Hadamard](xref:microsoft.quantum.glossary#hadamard), implementada pela [ `H` operação](xref:Microsoft.Quantum.Intrinsic.H).</span><span class="sxs-lookup"><span data-stu-id="cc63d-111">To prepare this state in Q#, start with the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the [Hadamard transform](xref:microsoft.quantum.glossary#hadamard), implemented by the [`H` operation](xref:Microsoft.Quantum.Intrinsic.H).</span></span> <span data-ttu-id="cc63d-112">O Q# código básico para inicializar e transformar um qubit, assim, tem a seguinte aparência:</span><span class="sxs-lookup"><span data-stu-id="cc63d-112">The basic Q# code to initialize and transform a qubit, then, looks like this:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, the qubit is in the state |0⟩.
    H(qubit);
    // H is now applied, such that the qubit is in H|0⟩ = |+⟩, as desired.
}
```
<span data-ttu-id="cc63d-113">Para obter mais informações sobre como inicializar, ou *alocar* , qubits, consulte [trabalhando com qubits](xref:microsoft.quantum.guide.qubits).</span><span class="sxs-lookup"><span data-stu-id="cc63d-113">For more information on initializing, or *allocating* , qubits, see [Working with qubits](xref:microsoft.quantum.guide.qubits).</span></span>

## <a name="quantum-states-in-no-locq"></a><span data-ttu-id="cc63d-114">Estados do Quantum em Q#</span><span class="sxs-lookup"><span data-stu-id="cc63d-114">Quantum states in Q#</span></span>

<span data-ttu-id="cc63d-115">O mais importante é que o programa anterior não se refere explicitamente ao estado no Q# , mas descreveu como nosso programa *transformou* o estado.</span><span class="sxs-lookup"><span data-stu-id="cc63d-115">Importantly, the previous program does not explicitly refer to the state within Q# but described how our program *transformed* the state.</span></span>
<span data-ttu-id="cc63d-116">Com essa abordagem, você pode ser totalmente independente do que um estado Quantum ainda *está* em cada computador de destino, que pode ter interpretações diferentes dependendo do computador.</span><span class="sxs-lookup"><span data-stu-id="cc63d-116">With this approach, you can be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="cc63d-117">Um Q# programa não pode introspecção no estado de um qubit.</span><span class="sxs-lookup"><span data-stu-id="cc63d-117">A Q# program cannot introspect into the state of a qubit.</span></span>
<span data-ttu-id="cc63d-118">Em vez disso, um programa pode chamar operações como [`Measure`](xref:Microsoft.Quantum.Intrinsic.Measure) para aprender informações de um qubit e chamar operações como [`X`](xref:Microsoft.Quantum.Intrinsic.X) e [`H`](xref:Microsoft.Quantum.Intrinsic.H) para agir no estado de um qubit.</span><span class="sxs-lookup"><span data-stu-id="cc63d-118">Instead, a program can call operations such as [`Measure`](xref:Microsoft.Quantum.Intrinsic.Measure) to learn information from a qubit, and call operations such as [`X`](xref:Microsoft.Quantum.Intrinsic.X) and [`H`](xref:Microsoft.Quantum.Intrinsic.H) to act on the state of a qubit.</span></span>
<span data-ttu-id="cc63d-119">O que essas operações realmente *fazem* é apenas concreto pelo computador de destino usado para executar o programa em particular Q# .</span><span class="sxs-lookup"><span data-stu-id="cc63d-119">What these operations actually *do* is only made concrete by the target machine used to run the particular Q# program.</span></span>
<span data-ttu-id="cc63d-120">Por exemplo, se estiver executando o programa em nosso [simulador de estado completo](xref:microsoft.quantum.machines.full-state-simulator), o simulador executará as operações matemáticas correspondentes para o sistema Quantum simulado.</span><span class="sxs-lookup"><span data-stu-id="cc63d-120">For example, if running the program on our [full-state simulator](xref:microsoft.quantum.machines.full-state-simulator), the simulator performs the corresponding mathematical operations to the simulated quantum system.</span></span>
<span data-ttu-id="cc63d-121">Mas olhando para o futuro, quando o computador de destino é um computador Quantum real, chamar essas operações em Q# direciona o computador Quantum para executar as operações *reais* correspondentes no sistema Quantum *real* , por exemplo, pulsos de laser com precisamente tempo.</span><span class="sxs-lookup"><span data-stu-id="cc63d-121">But looking toward the future, when the target machine is a real quantum computer, calling such operations in Q# directs the quantum computer to perform the corresponding *real* operations on the *real* quantum system, for example, precisely timed laser pulses).</span></span>

<span data-ttu-id="cc63d-122">Um Q# programa recombina essas operações conforme definido por um computador de destino para criar operações novas e de nível mais alto para a computação da Quantum Express.</span><span class="sxs-lookup"><span data-stu-id="cc63d-122">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="cc63d-123">Dessa forma, Q# o torna mais fácil expressar os algoritmos Quantum e Quantum híbrido subjacentes da lógica, além de ser geral em relação à estrutura de um computador de destino ou simulador.</span><span class="sxs-lookup"><span data-stu-id="cc63d-123">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum–classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="no-locq-operations-and-functions"></a><span data-ttu-id="cc63d-124">Q# operações e funções</span><span class="sxs-lookup"><span data-stu-id="cc63d-124">Q# operations and functions</span></span>

<span data-ttu-id="cc63d-125">Concretamente, um Q# programa consiste em *operações* , *funções* e qualquer tipo definido pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="cc63d-125">Concretely, a Q# program comprises *operations* , *functions* , and any user-defined types.</span></span> 

<span data-ttu-id="cc63d-126">As operações são usadas para descrever as transformações de sistemas Quantum e são o bloco de construção mais fundamental de Q# programas.</span><span class="sxs-lookup"><span data-stu-id="cc63d-126">Operations are used to describe the transformations of quantum systems and are the most fundamental building block of Q# programs.</span></span> <span data-ttu-id="cc63d-127">Cada operação definida em Q# pode então chamar qualquer número de outras operações.</span><span class="sxs-lookup"><span data-stu-id="cc63d-127">Each operation defined in Q# may then call any number of other operations.</span></span>

<span data-ttu-id="cc63d-128">Em contraste com as operações, as funções são usadas para descrever o comportamento clássico puramente *determinístico* e não têm efeitos além da computação de valores clássicos.</span><span class="sxs-lookup"><span data-stu-id="cc63d-128">In contrast to operations, functions are used to describe purely *deterministic* classical behavior and do not have any effects besides computing classical values.</span></span> <span data-ttu-id="cc63d-129">Por exemplo, suponha que você queira medir o qubits no final de um programa e adicionar os resultados de medida a uma matriz.</span><span class="sxs-lookup"><span data-stu-id="cc63d-129">For example, suppose you want to measure the qubits at the end of a program and add the measurement results to an array.</span></span>
<span data-ttu-id="cc63d-130">Nesse caso, `Measure` é uma *operação* que instrui o computador de destino a executar uma medida no qubits (real ou simulado).</span><span class="sxs-lookup"><span data-stu-id="cc63d-130">In this case, `Measure` is an *operation* that instructs the target machine to perform a measurement on the (real or simulated) qubits.</span></span> <span data-ttu-id="cc63d-131">Ao mesmo tempo, o *Functions* lida com o processo clássico de adicionar os resultados retornados a uma matriz.</span><span class="sxs-lookup"><span data-stu-id="cc63d-131">At the same time, *functions* handle the classical process of adding the returned results to an array.</span></span>

<span data-ttu-id="cc63d-132">Juntas, operações e funções são conhecidas como *callables* .</span><span class="sxs-lookup"><span data-stu-id="cc63d-132">Together, operations and functions are known as *callables* .</span></span> <span data-ttu-id="cc63d-133">A estrutura subjacente e o comportamento são introduzidos e detalhados em [operações Q# e funções no ](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="cc63d-133">Their underlying structure and behavior are introduced and detailed in [Operations and Functions in Q#](xref:microsoft.quantum.guide.operationsfunctions).</span></span>


## <a name="no-locq-syntax-overview"></a><span data-ttu-id="cc63d-134">Q# Visão geral da sintaxe</span><span class="sxs-lookup"><span data-stu-id="cc63d-134">Q# syntax overview</span></span>

<span data-ttu-id="cc63d-135">A sintaxe de uma linguagem descreve as diferentes combinações de símbolos que formam um programa sintaticamente correto.</span><span class="sxs-lookup"><span data-stu-id="cc63d-135">The syntax of a language describes the different combinations of symbols that form a syntactically correct program.</span></span>
<span data-ttu-id="cc63d-136">No Q# , os elementos de sintaxe são classificados em três grupos diferentes: tipos, expressões e instruções.</span><span class="sxs-lookup"><span data-stu-id="cc63d-136">In Q#, syntax elements are classified into three different groups: types, expressions, and statements.</span></span>

### <a name="types"></a><span data-ttu-id="cc63d-137">Tipos</span><span class="sxs-lookup"><span data-stu-id="cc63d-137">Types</span></span>
<span data-ttu-id="cc63d-138">Q# é uma linguagem fortemente tipada, de modo que o uso cuidadoso dos tipos pode ajudar o compilador a fornecer fortes garantias sobre Q# programas em tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="cc63d-138">Q# is a strongly-typed language, such that careful use of types can help the compiler provide strong guarantees about Q# programs at compile time.</span></span>
<span data-ttu-id="cc63d-139">Além dos tipos primitivos internos padrão e específicos do Quantum, por exemplo,,, `Int` `Bool` `Qubit` e `Result` , Q# fornece suporte para tipos definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="cc63d-139">In addition to standard and quantum-specific built-in primitive types, for example, `Int`, `Bool`, `Qubit`, and `Result`, Q# provides support for user-defined types.</span></span>

<span data-ttu-id="cc63d-140">Para obter descrições de todos os tipos primitivos, detalhes de matriz e tipos de tupla e etapas para definir novos tipos dentro de um Q# arquivo, consulte [tipos em Q# ](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="cc63d-140">For descriptions of all the primitive types, details for array and tuple types, and steps to define new types within a Q# file, see [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

### <a name="expressions"></a><span data-ttu-id="cc63d-141">Expressões</span><span class="sxs-lookup"><span data-stu-id="cc63d-141">Expressions</span></span>
<span data-ttu-id="cc63d-142">Uma expressão em uma linguagem de programação é uma combinação de uma ou mais constantes, variáveis, operadores e funções que a linguagem de programação interpreta e avalia como um valor específico.</span><span class="sxs-lookup"><span data-stu-id="cc63d-142">An expression in a programming language is a combination of one or more constants, variables, operators, and functions that the programming language interprets and evaluates to a specific value.</span></span>
<span data-ttu-id="cc63d-143">Mais simples, para cada tipo em um idioma, as expressões desse tipo podem ser *literais* ou símbolos associados a um valor desse tipo.</span><span class="sxs-lookup"><span data-stu-id="cc63d-143">Most simply, for every type in a language, expressions of that type can be either *literals* or symbols bound to a value of that type.</span></span>
<span data-ttu-id="cc63d-144">Por exemplo, `5` é um `Int` literal (portanto, também uma expressão do tipo `Int` ) e, se o símbolo `count` estiver associado ao valor inteiro `5` , `count` também será uma expressão de número inteiro.</span><span class="sxs-lookup"><span data-stu-id="cc63d-144">For example, `5` is an `Int` literal (thus also an expression of type `Int`), and if the symbol `count` is bound to the integer value `5`, then `count` is also an integer expression.</span></span>

<span data-ttu-id="cc63d-145">Além disso, uma expressão pode consistir em outras expressões combinadas por determinados operadores.</span><span class="sxs-lookup"><span data-stu-id="cc63d-145">Additionally, an expression can consist of other expressions combined by certain operators.</span></span>
<span data-ttu-id="cc63d-146">Por exemplo, outra `Int` expressão que é avaliada como `5` é `2+3` .</span><span class="sxs-lookup"><span data-stu-id="cc63d-146">For example, another `Int` expression that evaluates to `5` is `2+3`.</span></span>

<span data-ttu-id="cc63d-147">Para obter mais informações sobre expressões e operadores compatíveis no Q# , consulte [expressões de Q# tipo em ](xref:microsoft.quantum.guide.expressions).</span><span class="sxs-lookup"><span data-stu-id="cc63d-147">For more information about expressions and compatible operators in Q#, see [Type Expressions in Q#](xref:microsoft.quantum.guide.expressions).</span></span> 

### <a name="statements"></a><span data-ttu-id="cc63d-148">Instruções</span><span class="sxs-lookup"><span data-stu-id="cc63d-148">Statements</span></span> 
<span data-ttu-id="cc63d-149">Uma instrução é uma unidade sintática de uma linguagem de programação imperativa que expressa algumas ações a serem executadas. As instruções contrastam com expressões nessas instruções não retornam resultados e são executadas exclusivamente para seus efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="cc63d-149">A statement is a syntactic unit of an imperative programming language that expresses some action to carry out. Statements contrast with expressions in that statements do not return results and are run solely for their side effects.</span></span> <span data-ttu-id="cc63d-150">No entanto, as expressões sempre retornam um resultado e, muitas vezes, não têm nenhum efeito colateral.</span><span class="sxs-lookup"><span data-stu-id="cc63d-150">Expressions, however, always return a result and often do not have any side effects.</span></span> <span data-ttu-id="cc63d-151">Em suma, as Q# instruções são executadas, enquanto as expressões são avaliadas.</span><span class="sxs-lookup"><span data-stu-id="cc63d-151">In short, Q# statements are run, while expressions are evaluated.</span></span>

<span data-ttu-id="cc63d-152">Um exemplo simples de uma instrução no Q# é atribuir um símbolo a uma expressão:</span><span class="sxs-lookup"><span data-stu-id="cc63d-152">A simple example of a statement in Q# is assigning a symbol to an expression:</span></span>
```qsharp
let count = 5;
```

<span data-ttu-id="cc63d-153">Um exemplo mais interessante é a `for` instrução que dá suporte à iteração e inclui um *bloco de instruções* .</span><span class="sxs-lookup"><span data-stu-id="cc63d-153">A more interesting example is the `for` statement which supports iteration and includes a *statement block* .</span></span>
<span data-ttu-id="cc63d-154">Suponha que `qubits` o símbolo seja associado a um registro de qubits (tecnicamente do tipo `Qubit[]` , ou uma matriz de `Qubit` tipos).</span><span class="sxs-lookup"><span data-stu-id="cc63d-154">Suppose `qubits` is the symbol bound to a register of qubits (technically of type `Qubit[]`, or an array of `Qubit` types).</span></span> <span data-ttu-id="cc63d-155">Então</span><span class="sxs-lookup"><span data-stu-id="cc63d-155">Then</span></span>
```qsharp
for (qubit in qubits) {
    H(qubit);
}
```
<span data-ttu-id="cc63d-156">é uma instrução que itera em cada qubit no registro, executando a `H` operação em cada uma delas.</span><span class="sxs-lookup"><span data-stu-id="cc63d-156">is a statement that iterates over each qubit in the register, performing the `H` operation on each one.</span></span> <span data-ttu-id="cc63d-157">Observe que `H(qubit);` também é uma instrução em si.</span><span class="sxs-lookup"><span data-stu-id="cc63d-157">Note that `H(qubit);` is a statement in itself as well.</span></span>

<span data-ttu-id="cc63d-158">Você pode usar qualquer expressão de chamada do tipo `Unit` (um `Unit` tipo não retorna nenhuma informação) como uma instrução.</span><span class="sxs-lookup"><span data-stu-id="cc63d-158">You can use any call expression of type `Unit` (a `Unit` type does not return any information) as a statement.</span></span>
<span data-ttu-id="cc63d-159">Esse tipo de expressão é útil ao chamar operações em qubits que retornam `Unit` porque a finalidade da instrução é modificar o estado de Quantum implícito.</span><span class="sxs-lookup"><span data-stu-id="cc63d-159">This type of expression is useful when calling operations on qubits that return `Unit` because the purpose of the statement is to modify the implicit quantum state.</span></span>
<span data-ttu-id="cc63d-160">As instruções de avaliação de expressão exigem um ponto e vírgula de terminação.</span><span class="sxs-lookup"><span data-stu-id="cc63d-160">Expression evaluation statements require a terminating semicolon.</span></span>

<span data-ttu-id="cc63d-161">Você usa instruções para criar quase todos os aspectos de um Q# programa, e nenhuma única página pode abranger todas as informações relacionadas a eles.</span><span class="sxs-lookup"><span data-stu-id="cc63d-161">You use statements to build nearly every aspect of a Q# program, and no single page could encompass all the information relating to them.</span></span>
<span data-ttu-id="cc63d-162">Para obter mais informações sobre a estrutura lexical e a formatação, consulte [ Q# estrutura de arquivos](xref:microsoft.quantum.guide.filestructure); para atribuição e escopo de associação de símbolos, consulte [variáveis em Q# ](xref:microsoft.quantum.guide.variables); e para loops de fluxo de controle, como `for` , consulte [fluxo de controle em Q# ](xref:microsoft.quantum.guide.controlflow).</span><span class="sxs-lookup"><span data-stu-id="cc63d-162">For more information about their lexical structure and formatting, see [Q# File Structure](xref:microsoft.quantum.guide.filestructure); for symbol binding assignment and scope, see [Variables in Q#](xref:microsoft.quantum.guide.variables); and for control flow loops such as `for`, see [Control Flow in Q#](xref:microsoft.quantum.guide.controlflow).</span></span>

## <a name="next-steps"></a><span data-ttu-id="cc63d-163">Próximas etapas</span><span class="sxs-lookup"><span data-stu-id="cc63d-163">Next steps</span></span>

<span data-ttu-id="cc63d-164">Comece a aprender sobre os [tipos no Q# ](xref:microsoft.quantum.guide.types).</span><span class="sxs-lookup"><span data-stu-id="cc63d-164">Start learning about [Types in Q#](xref:microsoft.quantum.guide.types).</span></span>

<span data-ttu-id="cc63d-165">Para obter mais informações sobre as bases e a motivação por trás Q# , consulte [por que precisamos Q# ?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span><span class="sxs-lookup"><span data-stu-id="cc63d-165">For more background about the foundations and motivation behind Q#, see [Why do we need Q#?](https://devblogs.microsoft.com/qsharp/why-do-we-need-q/).</span></span>
