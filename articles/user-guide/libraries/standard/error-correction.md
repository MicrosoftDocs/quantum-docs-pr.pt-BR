---
title: Correção de erro nas Q# bibliotecas padrão
description: Saiba como usar códigos de correção de erro em seus Q# programas enquanto protege o estado do qubits.
author: QuantumWriter
uid: microsoft.quantum.libraries.error-correction
ms.author: martinro
ms.date: 12/11/2017
ms.topic: conceptual
no-loc:
- Q#
- $$v
ms.openlocfilehash: fc8e46aa22cb2575de42cfc3d4f57c43e5d3f7b0
ms.sourcegitcommit: 71605ea9cc630e84e7ef29027e1f0ea06299747e
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 01/26/2021
ms.locfileid: "98857201"
---
# <a name="error-correction"></a><span data-ttu-id="e1ffc-103">Correção de erro</span><span class="sxs-lookup"><span data-stu-id="e1ffc-103">Error Correction</span></span> #

## <a name="introduction"></a><span data-ttu-id="e1ffc-104">Introdução</span><span class="sxs-lookup"><span data-stu-id="e1ffc-104">Introduction</span></span> ##

<span data-ttu-id="e1ffc-105">Na computação clássica, se alguém quiser proteger um pouco contra erros, muitas vezes poderá representar esse bit por um *bit lógico* repetindo o bit de dados.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-105">In classical computing, if one wants to protect a bit against errors, it can often suffice to represent that bit by a *logical bit* by repeating the data bit.</span></span>
<span data-ttu-id="e1ffc-106">Por exemplo, deixe que $ \overline {0} = $0 seja a codificação do bit de dados 0, em que usamos uma linha acima do rótulo 0 para indicar que é uma codificação de um bit no estado 0.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-106">For instance, let $\overline{0} = 000$ be the encoding of the data bit 0, where we use the a line above the label 0 to indicate that it is an encoding of a bit in the 0 state.</span></span>
<span data-ttu-id="e1ffc-107">Se, de forma semelhante, permitimos $ \overline {1} = $111, temos um código de repetição simples que protege contra um erro de inversão de um bit.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-107">If we similarly let $\overline{1} = 111$, then we have a simple repetition code that protects against any one bit flip error.</span></span>
<span data-ttu-id="e1ffc-108">Ou seja, se qualquer um dos três bits for invertido, podemos recuperar o estado do bit lógico assumindo um voto principal.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-108">That is, if any of the three bits are flipped, then we can recover the state of the logical bit by taking a majority vote.</span></span>
<span data-ttu-id="e1ffc-109">Embora a correção de erro clássica seja um assunto muito mais rico que esse exemplo específico (Recomendamos [a introdução de fiapos à teoria de codificação](https://www.springer.com/us/book/9783540641339)), o código de repetição acima já aponta para um possível problema na proteção de informações da Quantum.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-109">Though classical error correction is a much richer subject that this particular example (we recommend [Lint's introduction to coding theory](https://www.springer.com/us/book/9783540641339)), the repetition code above already points to a possible problem in protecting quantum information.</span></span>
<span data-ttu-id="e1ffc-110">Ou seja, o [teorema no-Cloning](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implica que, se medirmos cada qubit individual e pegarmos um voto de maioria por analogia com o código clássico acima, perdemos as informações precisas que estamos tentando proteger.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-110">Namely, the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) implies that if we measure each individual qubit and take a majority vote by analogy to classical code above, then we have lost the precise information that we are trying to protect.</span></span>

<span data-ttu-id="e1ffc-111">Na configuração Quantum, veremos que a medida é problemática.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-111">In the quantum setting, we will see that the measurement is problematic.</span></span> <span data-ttu-id="e1ffc-112">Ainda podemos implementar a codificação acima.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-112">We can still implement the encoding above.</span></span>
<span data-ttu-id="e1ffc-113">É útil fazer isso para ver como é possível generalizar a correção de erro para o caso Quantum.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-113">It is helpful to do so to see how we can generalize error correction to the quantum case.</span></span>
<span data-ttu-id="e1ffc-114">Portanto, Let $ \ket{\overline {0} } = \ket {000} = \ket {0} \otimes \ket {0} \otimes \ket {0} $ e Let $ \ket{\overline {1} } = \ket {111} $.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-114">Thus, let $\ket{\overline{0}} = \ket{000} = \ket{0} \otimes \ket{0} \otimes \ket{0}$, and let $\ket{\overline{1}} = \ket{111}$.</span></span>
<span data-ttu-id="e1ffc-115">Em seguida, por linearidade, definimos nosso código de repetição para todas as entradas; por exemplo, $ \ket{\overline{+}} = (\ket{\overline {0} } + \ket{\overline {1} })/\sqrt {2} = (\ket {000} + \ket {111} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-115">Then, by linearity, we have defined our repetition code for all inputs; for instance, $\ket{\overline{+}} = (\ket{\overline{0}} + \ket{\overline{1}}) / \sqrt{2} = (\ket{000} + \ket{111}) / \sqrt{2}$.</span></span>
<span data-ttu-id="e1ffc-116">Em particular, deixando um erro de inversão $X o _1 $ Act no meio qubit, vemos que a correção necessária em ambas as ramificações é precisamente $X _1 $: $ $ \begin{align} X_1 \ket{\overline{+}} & = \frac {1} {\sqrt {2} } \left (X_1 \ket {000} + X_1 \ket {111} \right) \\ \\ & = \frac {1} {\sqrt {2} } \left (\ket {010} + \ket {101} \right).</span><span class="sxs-lookup"><span data-stu-id="e1ffc-116">In particular, letting a bit-flip error $X_1$ act on the middle qubit, we see that the correction needed in both branches is precisely $X_1$: $$ \begin{align} X_1 \ket{\overline{+}} & = \frac{1}{\sqrt{2}} \left( X_1 \ket{000} + X_1 \ket{111} \right) \\\\ & = \frac{1}{\sqrt{2}} \left( \ket{010} + \ket{101} \right).</span></span>
<span data-ttu-id="e1ffc-117">\end{align} $ $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-117">\end{align} $$</span></span>

<span data-ttu-id="e1ffc-118">Para ver como podemos identificar que esse é o caso sem medir o estado que estamos tentando proteger, é útil anotar o que significa cada erro de inversão de bit diferente para nossos Estados lógicos:</span><span class="sxs-lookup"><span data-stu-id="e1ffc-118">To see how we can identify that this is the case without measuring the very state we are trying to protect, it is helpful to write down what each different bit flip error does to our logical states:</span></span>

| <span data-ttu-id="e1ffc-119">Erro $E $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-119">Error $E$</span></span> | <span data-ttu-id="e1ffc-120">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-120">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="e1ffc-121">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-121">$E\ket{\overline{1}}$</span></span> |
| --- | --- | --- |
| <span data-ttu-id="e1ffc-122">US $ \boldone $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-122">$\boldone$</span></span> | <span data-ttu-id="e1ffc-123">US $ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-123">$\ket{000}$</span></span> | <span data-ttu-id="e1ffc-124">US $ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-124">$\ket{111}$</span></span> |
| <span data-ttu-id="e1ffc-125">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-125">$X_0$</span></span> | <span data-ttu-id="e1ffc-126">US $ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-126">$\ket{100}$</span></span> | <span data-ttu-id="e1ffc-127">US $ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-127">$\ket{011}$</span></span> |
| <span data-ttu-id="e1ffc-128">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-128">$X_1$</span></span> | <span data-ttu-id="e1ffc-129">US $ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-129">$\ket{010}$</span></span> | <span data-ttu-id="e1ffc-130">US $ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-130">$\ket{101}$</span></span> |
| <span data-ttu-id="e1ffc-131">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-131">$X_2$</span></span> | <span data-ttu-id="e1ffc-132">US $ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-132">$\ket{001}$</span></span> | <span data-ttu-id="e1ffc-133">US $ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-133">$\ket{110}$</span></span> |

<span data-ttu-id="e1ffc-134">Para proteger o estado que estamos codificando, precisamos ser capaz de distinguir os três erros uns dos outros e da identidade $ \boldone $ sem distinção entre $ \ket{\overline {0} } $ e $ \ket{\overline {1} } $.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-134">In order to protect the state that we're encoding, we need to be able to distinguish the three errors from each other and from the identity $\boldone$ without distinguishing between $\ket{\overline{0}}$ and $\ket{\overline{1}}$.</span></span>
<span data-ttu-id="e1ffc-135">Por exemplo, se medirmos $Z _0 $, obteremos um resultado diferente para $ \ket{\overline {0} } $ e $ \ket{\overline {1} } $ no caso no-Error, para que recolha o estado codificado.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-135">For example, if we measure $Z_0$, we get a different result for $\ket{\overline{0}}$ and $\ket{\overline{1}}$ in the no-error case, so that collapses the encoded state.</span></span>
<span data-ttu-id="e1ffc-136">Por outro lado, considere medir $Z _0 Z_1 $, a paridade dos dois primeiros bits em cada Estado de base computacional.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-136">On the other hand, consider measuring $Z_0 Z_1$, the parity of the first two bits in each computational basis state.</span></span>
<span data-ttu-id="e1ffc-137">Lembre-se de que cada medida de um operador Pauli verifica a qual eigenvalue o estado que está sendo medido corresponde a, portanto, para cada Estado $ \ket{\psi} $ na tabela acima, podemos calcular $Z _0 Z_1 \ket{\psi} $ para ver se obtemos $ \pm\ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-137">Recall that each measurement of a Pauli operator checks which eigenvalue  the state being measured corresponds to, so for each state $\ket{\psi}$ in the table above, we can compute $Z_0 Z_1 \ket{\psi}$ to see if we get $\pm\ket{\psi}$.</span></span>
<span data-ttu-id="e1ffc-138">Observe que $Z _0 Z_1 \ket {000} = \ket {000} $ e que $Z _0 Z_1 \ket {111} = \ket {111} $, para que possamos concluir que essa medida faz a mesma coisa para ambos os Estados codificados.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-138">Note that $Z_0 Z_1 \ket{000} = \ket{000}$ and that $Z_0 Z_1 \ket{111} = \ket{111}$, so that we conclude that this measurement does the same thing to both encoded states.</span></span>
<span data-ttu-id="e1ffc-139">Por outro lado, $Z _0 Z_1 \ket {100} =-\ket {100} $ e $Z _0 Z_1 \ket {011} =-\ket {011} $, portanto, o resultado da medição de $Z _0 Z_1 $ revela informações úteis sobre o erro ocorrido.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-139">On the other hand, $Z_0 Z_1 \ket{100} = - \ket{100}$ and $Z_0 Z_1 \ket{011} = -\ket{011}$, so the result of measuring $Z_0 Z_1$ reveals useful information about which error occurred.</span></span>

<span data-ttu-id="e1ffc-140">Para enfatizar isso, repetimos a tabela acima, mas adiciono os resultados da medição de $Z _0 Z_1 $ e $Z _1 Z_2 $ em cada linha.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-140">To emphasize this, we repeat the table above, but add the results of measuring $Z_0 Z_1$ and $Z_1 Z_2$ on each row.</span></span>
<span data-ttu-id="e1ffc-141">Denotamos os resultados de cada medição pelo sinal do eigenvalue observado, $ + $ ou $-$, que corresponde aos Q# `Result` valores de `Zero` e `One` , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-141">We denote the results of each measurement by the sign of the eigenvalue that is observed, either $+$ or $-$, corresponding to the Q# `Result` values of `Zero` and `One`, respectively.</span></span>

| <span data-ttu-id="e1ffc-142">Erro $E $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-142">Error $E$</span></span> | <span data-ttu-id="e1ffc-143">$E \ket{\overline {0} } $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-143">$E\ket{\overline{0}}$</span></span> | <span data-ttu-id="e1ffc-144">$E \ket{\overline {1} } $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-144">$E\ket{\overline{1}}$</span></span> | <span data-ttu-id="e1ffc-145">Resultado de $Z _0 Z_1 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-145">Result of $Z_0 Z_1$</span></span> | <span data-ttu-id="e1ffc-146">Resultado de $Z _1 Z_2 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-146">Result of $Z_1 Z_2$</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="e1ffc-147">US $ \boldone $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-147">$\boldone$</span></span> | <span data-ttu-id="e1ffc-148">US $ \ket {000} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-148">$\ket{000}$</span></span> | <span data-ttu-id="e1ffc-149">US $ \ket {111} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-149">$\ket{111}$</span></span> | $+$ | $+$ |
| <span data-ttu-id="e1ffc-150">$X _0 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-150">$X_0$</span></span> | <span data-ttu-id="e1ffc-151">US $ \ket {100} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-151">$\ket{100}$</span></span> | <span data-ttu-id="e1ffc-152">US $ \ket {011} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-152">$\ket{011}$</span></span> | $-$ | $+$ |
| <span data-ttu-id="e1ffc-153">$X _1 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-153">$X_1$</span></span> | <span data-ttu-id="e1ffc-154">US $ \ket {010} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-154">$\ket{010}$</span></span> | <span data-ttu-id="e1ffc-155">US $ \ket {101} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-155">$\ket{101}$</span></span> | $-$ | $-$ |
| <span data-ttu-id="e1ffc-156">$X _2 $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-156">$X_2$</span></span> | <span data-ttu-id="e1ffc-157">US $ \ket {001} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-157">$\ket{001}$</span></span> | <span data-ttu-id="e1ffc-158">US $ \ket {110} $</span><span class="sxs-lookup"><span data-stu-id="e1ffc-158">$\ket{110}$</span></span> | $+$ | $-$ |

<span data-ttu-id="e1ffc-159">Assim, os resultados das duas medições determinam exclusivamente qual erro de inversão de bit ocorreu, mas sem revelar nenhuma informação sobre o estado que codificamos.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-159">Thus, the results of the two measurements uniquely determines which bit-flip error occurred, but without revealing any information about which state we encoded.</span></span>
<span data-ttu-id="e1ffc-160">Chamamos esses resultados de uma *síndrome* e referimos-se ao processo de mapeamento de uma síndrome de volta para o erro que o causou como *recuperação*.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-160">We call these results a *syndrome*, and refer to the process of mapping a syndrome back to the error that caused it as *recovery*.</span></span>
<span data-ttu-id="e1ffc-161">Em particular, enfatizamos que a recuperação é um procedimento de inferência *clássico* que usa como entrada a síndrome que ocorreu e retorna uma receita para corrigir quaisquer erros que possam ter ocorrido.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-161">In particular, we emphasize that recovery is a *classical* inference procedure which takes as its input the syndrome which occurred, and returns a prescription for how to fix any errors that may have occurred.</span></span>

> [!NOTE]
> <span data-ttu-id="e1ffc-162">O código de inversão de bits acima só pode corrigir em caso de erros de flip-bit único; ou seja, uma `X` operação agindo em um único qubit.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-162">The bit-flip code above can only correct against single bit-flip errors; that is, an `X` operation acting on a single qubit.</span></span>
> <span data-ttu-id="e1ffc-163">`X`A aplicação de mais de um qubit irá mapear $ \ket{\overline {0} } $ para $ \ket{\overline {1} } $ após a recuperação.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-163">Applying `X` to more than one qubit will map $\ket{\overline{0}}$ to $\ket{\overline{1}}$ following recovery.</span></span>
> <span data-ttu-id="e1ffc-164">Da mesma forma, a aplicação de uma operação de inversão de fase `Z` mapeará $ \ket{\overline {1} } $ para $-\ket{\overline {1} } $ e, portanto, mapeará $ \ket{\overline{+}} $ para $ \ket{\overline {-} } $.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-164">Similarly, applying a phase flip operation `Z` will map $\ket{\overline{1}}$ to $-\ket{\overline{1}}$, and hence will map $\ket{\overline{+}}$ to $\ket{\overline{-}}$.</span></span>
> <span data-ttu-id="e1ffc-165">Em geral, os códigos podem ser criados para lidar com um número maior de erros e para manipular $Z $ erros, bem como $X $ erros.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-165">More generally, codes can be created to handle larger number of errors, and to handle $Z$ errors as well as $X$ errors.</span></span>

<span data-ttu-id="e1ffc-166">A percepção de que podemos descrever as medidas na correção de erro Quantum que atuam da mesma forma em todos os Estados de código, é a essência do *semiformal do estabilizador*.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-166">The insight that we can describe measurements in quantum error correction that act the same way on all code states, is the essence of the *stabilizer formalism*.</span></span>
<span data-ttu-id="e1ffc-167">A Q# Canon fornece uma estrutura para descrever a codificação e decodificação de códigos de estabilizador e para descrever como um se recupera de erros.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-167">The Q# canon provides a framework for describing encoding into and decoding from stabilizer codes, and for describing how one recovers from errors.</span></span>
<span data-ttu-id="e1ffc-168">Nesta seção, descrevemos essa estrutura e seu aplicativo com alguns códigos de correção de erro de Quantum simples.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-168">In this section, we describe this framework and its application to a few simple quantum error-correcting codes.</span></span>

> [!TIP]
> <span data-ttu-id="e1ffc-169">Uma introdução completa ao informativo do estabilizador está além do escopo desta seção.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-169">A full introduction to the stabilizer formalism is beyond the scope of this section.</span></span>
> <span data-ttu-id="e1ffc-170">Nós nos referimos aos leitores interessados em aprender mais sobre o [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span><span class="sxs-lookup"><span data-stu-id="e1ffc-170">We refer readers interested in learning more to [Gottesman 2009](https://arxiv.org/abs/0904.2557).</span></span>

## <a name="representing-error-correcting-codes-in-no-locq"></a><span data-ttu-id="e1ffc-171">Representando códigos de correção de erro no Q#</span><span class="sxs-lookup"><span data-stu-id="e1ffc-171">Representing Error Correcting Codes in Q#</span></span> ##

<span data-ttu-id="e1ffc-172">Para ajudar a especificar códigos de correção de erro, a Q# Canon fornece vários tipos distintos definidos pelo usuário:</span><span class="sxs-lookup"><span data-stu-id="e1ffc-172">To help specify error correcting codes, the Q# canon provides several distinct user-defined types:</span></span>

- <span data-ttu-id="e1ffc-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister>`= Qubit[]`: Indica que um registro de qubits deve ser interpretado como o bloco de código de um código de correção de erro.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-173"><xref:Microsoft.Quantum.ErrorCorrection.LogicalRegister> `= Qubit[]`: Denotes that a register of qubits should be interpreted as the code block of an error-correcting code.</span></span>
- <span data-ttu-id="e1ffc-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome>`= Result[]`: Indica que uma matriz de resultados de medição deve ser interpretada como a síndrome medida em um bloco de código.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-174"><xref:Microsoft.Quantum.ErrorCorrection.Syndrome> `= Result[]`: Denotes that an array of measurement results should be interpreted as the syndrome measured on a code block.</span></span>
- <span data-ttu-id="e1ffc-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn>`= (Syndrome -> Pauli[])`: Indica que uma função *clássica* deve ser usada para interpretar uma síndrome e retornar uma correção que deve ser aplicada.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-175"><xref:Microsoft.Quantum.ErrorCorrection.RecoveryFn> `= (Syndrome -> Pauli[])`: Denotes that a *classical* function should be used to interpret a syndrome and return a correction that should be applied.</span></span>
- <span data-ttu-id="e1ffc-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp>`= ((Qubit[], Qubit[]) => LogicalRegister)`: Indica que uma operação usa qubits que representa dados junto com a nova ancilla qubits para produzir um bloco de código de um código de correção de erro.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-176"><xref:Microsoft.Quantum.ErrorCorrection.EncodeOp> `= ((Qubit[], Qubit[]) => LogicalRegister)`: Denotes that an operation takes qubits representing data along with fresh ancilla qubits in order to produce a code block of an error-correcting code.</span></span>
- <span data-ttu-id="e1ffc-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp>`= (LogicalRegister => (Qubit[], Qubit[]))`: Indica que uma operação decompõe um bloco de código de um erro corrigindo o código no qubits de dados e o ancilla qubits usado para representar informações sobre a síndrome.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-177"><xref:Microsoft.Quantum.ErrorCorrection.DecodeOp> `= (LogicalRegister => (Qubit[], Qubit[]))`: Denotes than an operation decomposes a code block of an error correcting code into the data qubits and the ancilla qubits used to represent syndrome information.</span></span>
- <span data-ttu-id="e1ffc-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp>`= (LogicalRegister => Syndrome)`: Denota uma operação que deve ser usada para extrair informações de síndrome de um bloco de código, sem perturbar o estado protegido pelo código.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-178"><xref:Microsoft.Quantum.ErrorCorrection.SyndromeMeasOp> `= (LogicalRegister => Syndrome)`: Denotes an operation that should be used to extract syndrome information from a code block, without disturbing the state protected by the code.</span></span>

<span data-ttu-id="e1ffc-179">Por fim, a Canon fornece o <xref:Microsoft.Quantum.ErrorCorrection.QECC> tipo para coletar os outros tipos necessários para definir um código de correção de erro Quantum.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-179">Finally, the canon provides the <xref:Microsoft.Quantum.ErrorCorrection.QECC> type to collect the other types required to define a quantum error-correcting code.</span></span> <span data-ttu-id="e1ffc-180">Associado a cada código Quantum do estabilizador é o tamanho do código $n $, o número $k $ of Logical qubits e a distância mínima $d $, geralmente agrupados em conjunto na notação ⟦ $n $, $k $, $d $ ⟧.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-180">Associated with each stabilizer quantum code is the code length $n$, the number $k$ of logical qubits, and the minimum distance $d$, often conveniently grouped together in the notation ⟦$n$, $k$, $d$⟧.</span></span> <span data-ttu-id="e1ffc-181">Por exemplo, a <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> função define o ⟦ 3, 1, 1 ⟧ bit flip Code:</span><span class="sxs-lookup"><span data-stu-id="e1ffc-181">For example, the <xref:Microsoft.Quantum.ErrorCorrection.BitFlipCode> function defines the ⟦3, 1, 1⟧ bit flip code:</span></span>

```qsharp
let encodeOp = EncodeOp(BitFlipEncoder);
let decodeOp = DecodeOp(BitFlipDecoder);
let syndMeasOp = SyndromeMeasOp(MeasureStabilizerGenerators([
    [PauliZ, PauliZ, PauliI],
    [PauliI, PauliZ, PauliZ]
], _, MeasureWithScratch));
let code = QECC(encodeOp, decodeOp, syndMeasOp);
```

<span data-ttu-id="e1ffc-182">Observe que o `QECC` tipo *não* inclui uma função de recuperação.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-182">Notice that the `QECC` type does *not* include a recovery function.</span></span>
<span data-ttu-id="e1ffc-183">Isso nos permite alterar a função de recuperação que é usada na correção de erros sem alterar a definição do próprio código; Essa capacidade é particularmente útil ao incorporar comentários de medidas de caracterização ao modelo assumido pela recuperação.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-183">This allows us to change the recovery function that is used in correcting errors without changing the definition of the code itself; this ability is in particular useful when incorporating feedback from characterization measurements into the model assumed by recovery.</span></span>

<span data-ttu-id="e1ffc-184">Depois que um código é definido dessa forma, podemos usar a <xref:Microsoft.Quantum.ErrorCorrection.Recover> operação para se recuperar de erros:</span><span class="sxs-lookup"><span data-stu-id="e1ffc-184">Once a code is defined in this way, we can use the <xref:Microsoft.Quantum.ErrorCorrection.Recover> operation to recover from errors:</span></span>

```qsharp
let code = BitFlipCode();
let fn = BitFlipRecoveryFn();
let X0 = ApplyPauli([PauliX, PauliI, PauliI], _);
using (scratch = Qubit[nScratch]) {
    let logicalRegister = encode(data, scratch);
    // Cause an error.
    X0(logicalRegister);
    Recover(code, fn, logicalRegister);
    let (decodedData, decodedScratch) = decode(logicalRegister);
    ApplyToEach(Reset, decodedScratch);
}
```

<span data-ttu-id="e1ffc-185">Exploraremos isso mais detalhadamente na [amostra de código de inversão de bits](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span><span class="sxs-lookup"><span data-stu-id="e1ffc-185">We explore this in more detail in the [bit flip code sample](https://github.com/microsoft/Quantum/tree/main/samples/error-correction/bit-flip-code).</span></span>

<span data-ttu-id="e1ffc-186">Além do código de inversão de bits, a Q# Canon é fornecida com implementações do [código perfeito de cinco qubit](https://arxiv.org/abs/quant-ph/9602019)e o [código de sete qubit](https://arxiv.org/abs/quant-ph/9705052), que pode corrigir um erro arbitrário de qubit único.</span><span class="sxs-lookup"><span data-stu-id="e1ffc-186">Aside from the bit-flip code, the Q# canon is provided with implementations of the [five-qubit perfect code](https://arxiv.org/abs/quant-ph/9602019), and the [seven-qubit code](https://arxiv.org/abs/quant-ph/9705052), both of which can correct an arbitrary single-qubit error.</span></span>
