---
title: 'Diagnóstico nas :::no-loc(Q#)::: bibliotecas padrão'
description: 'Saiba mais sobre as funções de diagnóstico e as operações nas :::no-loc(Q#)::: bibliotecas padrão usadas para capturar erros ou erros em programas Quantum.'
author: cgranade
uid: microsoft.quantum.libraries.diagnostics
ms.author: chgranad
ms.topic: article
no-loc:
- ':::no-loc(Q#):::'
- ':::no-loc($$v):::'
ms.openlocfilehash: 1ab9b77c7536a1860064110810371d3a68e95b40
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/27/2020
ms.locfileid: "92690856"
---
# <a name="diagnostics"></a><span data-ttu-id="15a92-103">Diagnósticos</span><span class="sxs-lookup"><span data-stu-id="15a92-103">Diagnostics</span></span> #

<span data-ttu-id="15a92-104">Assim como no desenvolvimento clássico, é importante poder diagnosticar erros e erros em programas Quantum.</span><span class="sxs-lookup"><span data-stu-id="15a92-104">As with classical development, it is important to be able to diagnose mistakes and errors in quantum programs.</span></span>
<span data-ttu-id="15a92-105">As :::no-loc(Q#)::: bibliotecas padrão fornecem várias maneiras diferentes de garantir a exatidão dos programas Quantum, conforme detalhado em <xref:microsoft.quantum.guide.testingdebugging> .</span><span class="sxs-lookup"><span data-stu-id="15a92-105">The :::no-loc(Q#)::: standard libraries provide a variety of different ways to ensure the correctness of quantum programs, as detailed in <xref:microsoft.quantum.guide.testingdebugging>.</span></span>
<span data-ttu-id="15a92-106">Em grande parte, esse suporte é fornecido na forma de funções e operações que instruem o computador de destino a fornecer informações adicionais de diagnóstico para o programa ou desenvolvedor do host, ou impõem a exatidão das condições e invariáveis expressas pela função ou pela chamada de operação.</span><span class="sxs-lookup"><span data-stu-id="15a92-106">Largely speaking, this support comes in the form of functions and operations that either instruct the target machine to provide additional diagnostic information to the host program or developer, or enforce the correctness of conditions and invariants expressed by the function or operation call.</span></span>

## <a name="machine-diagnostics"></a><span data-ttu-id="15a92-107">Diagnóstico de máquina</span><span class="sxs-lookup"><span data-stu-id="15a92-107">Machine Diagnostics</span></span> ##

<span data-ttu-id="15a92-108">O diagnóstico sobre valores clássicos pode ser obtido usando a <xref:Microsoft.Quantum.Intrinsic.Message> função para registrar uma mensagem de forma dependente do computador.</span><span class="sxs-lookup"><span data-stu-id="15a92-108">Diagnostics about classical values can be obtained by using the <xref:Microsoft.Quantum.Intrinsic.Message> function to log a message in a machine-dependent way.</span></span>
<span data-ttu-id="15a92-109">Por padrão, isso grava a cadeia de caracteres no console.</span><span class="sxs-lookup"><span data-stu-id="15a92-109">By default, this writes the string to the console.</span></span>
<span data-ttu-id="15a92-110">Usado junto com cadeias de caracteres interpoladas, <xref:Microsoft.Quantum.Intrinsic.Message> facilita o relatório de informações de diagnóstico sobre valores clássicos:</span><span class="sxs-lookup"><span data-stu-id="15a92-110">Used together with interpolated strings, <xref:Microsoft.Quantum.Intrinsic.Message> makes it easy to report diagnostic information about classical values:</span></span>

```:::no-loc(Q#):::
let angle = Microsoft.Quantum.Math.PI() * 2.0 / 3.0;
Message($"About to rotate by an angle of {angle}...");
```

> [!NOTE]
> <span data-ttu-id="15a92-111">`Message` tem assinatura `(String -> Unit)` , representando novamente que a emissão de uma mensagem de log de depuração não pode ser observada de dentro do :::no-loc(Q#)::: .</span><span class="sxs-lookup"><span data-stu-id="15a92-111">`Message` has signature `(String -> Unit)`, again representing that emitting a debug log message cannot be observed from within :::no-loc(Q#):::.</span></span>

<span data-ttu-id="15a92-112">O <xref:Microsoft.Quantum.Diagnostics.DumpMachine> e o <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instruem os computadores de destino a fornecer informações de diagnóstico sobre todos os qubits atualmente alocados ou sobre um registro específico do qubits, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="15a92-112">The <xref:Microsoft.Quantum.Diagnostics.DumpMachine> and <xref:Microsoft.Quantum.Diagnostics.DumpRegister> callables instruct target machines to provide diagnostic information about all currently allocated qubits or about a specific register of qubits, respectively.</span></span>
<span data-ttu-id="15a92-113">Cada computador de destino varia de acordo com as informações de diagnóstico fornecidas em resposta a uma instrução de despejo.</span><span class="sxs-lookup"><span data-stu-id="15a92-113">Each target machine varies in what diagnostic information is provided in response to a dump instruction.</span></span>
<span data-ttu-id="15a92-114">A máquina de destino do [simulador de estado completo](xref:microsoft.quantum.machines.full-state-simulator) , por exemplo, fornece o programa de host com o vetor de estado que ele usa internamente para representar um registro de qubits.</span><span class="sxs-lookup"><span data-stu-id="15a92-114">The [full state simulator](xref:microsoft.quantum.machines.full-state-simulator) target machine, for instance, provides the host program with the state vector that it uses internally to represent a register of qubits.</span></span>
<span data-ttu-id="15a92-115">Por comparação, a máquina de destino do [Toffoli Simulator](xref:microsoft.quantum.machines.toffoli-simulator) fornece um único bit clássico para cada qubit.</span><span class="sxs-lookup"><span data-stu-id="15a92-115">By comparison, the [Toffoli simulator](xref:microsoft.quantum.machines.toffoli-simulator) target machine provides a single classical bit for each qubit.</span></span>

 <span data-ttu-id="15a92-116">Para saber mais sobre a saída [do simulador de estado completo](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` , dê uma olhada na seção de funções de despejo do nosso [artigo de teste e depuração](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span><span class="sxs-lookup"><span data-stu-id="15a92-116">To learn more about the [full state simulator's](xref:microsoft.quantum.machines.full-state-simulator) `DumpMachine` output, take a look at the dump functions section of our [testing and debugging article](xref:microsoft.quantum.guide.testingdebugging#dump-functions).</span></span>


## <a name="facts-and-assertions"></a><span data-ttu-id="15a92-117">Fatos e asserções</span><span class="sxs-lookup"><span data-stu-id="15a92-117">Facts and Assertions</span></span> ##

<span data-ttu-id="15a92-118">Conforme discutido em [teste e depuração](xref:microsoft.quantum.guide.testingdebugging), uma função ou operação com assinatura `Unit -> Unit` ou `Unit => Unit` , respectivamente, pode ser marcada como um *teste de unidade* .</span><span class="sxs-lookup"><span data-stu-id="15a92-118">As discussed in [Testing and Debugging](xref:microsoft.quantum.guide.testingdebugging), a function or operation with signature `Unit -> Unit` or `Unit => Unit`, respectively, can be marked as a *unit test* .</span></span>
<span data-ttu-id="15a92-119">Cada teste de unidade geralmente consiste em um pequeno programa Quantum, juntamente com uma ou mais condições que verificam a exatidão desse programa.</span><span class="sxs-lookup"><span data-stu-id="15a92-119">Each unit test generally consists of a small quantum program, along with one or more conditions that check the correctness of that program.</span></span>
<span data-ttu-id="15a92-120">Essas condições podem vir na forma de _fatos_ , que verificam os valores de suas entradas ou _asserções_ , que verificam os Estados de um ou mais qubits passados como entrada.</span><span class="sxs-lookup"><span data-stu-id="15a92-120">These conditions can come in the form of either _facts_ , which check the values of their inputs, or _assertions_ , which check the states of one or more qubits passed as input.</span></span>

<span data-ttu-id="15a92-121">Por exemplo, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` representa o fato matemático que $1 + 1 = $2, enquanto `AssertQubit(One, qubit)` representa a condição que a medição `qubit` retornará um `One` com certeza.</span><span class="sxs-lookup"><span data-stu-id="15a92-121">For example, `EqualityFactI(1 + 1, 2, "1 + 1 != 2")` represents the mathematical fact that $1 + 1 = 2$, while `AssertQubit(One, qubit)` represents the condition that measuring `qubit` will return a `One` with certainty.</span></span>
<span data-ttu-id="15a92-122">No primeiro caso, podemos verificar a exatidão da condição, dado apenas seus valores, enquanto, no último, devemos saber algo sobre o estado do qubit para avaliar a asserção.</span><span class="sxs-lookup"><span data-stu-id="15a92-122">In the former case, we can check the correctness of the condition given only its values, while in the latter, we must know something about the state of the qubit in order to evaluate the assertion.</span></span>

<span data-ttu-id="15a92-123">As :::no-loc(Q#)::: bibliotecas padrão fornecem várias funções diferentes para representar fatos, incluindo:</span><span class="sxs-lookup"><span data-stu-id="15a92-123">The :::no-loc(Q#)::: standard libraries provide several different functions for representing facts, including:</span></span>

- <xref:Microsoft.Quantum.Diagnostics.Fact>
- <xref:Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact>
- <xref:Microsoft.Quantum.Diagnostics.NearEqualityFactC>
- <xref:Microsoft.Quantum.Diagnostics.EqualityFactI>


### <a name="testing-qubit-states"></a><span data-ttu-id="15a92-124">Testando Estados de qubit</span><span class="sxs-lookup"><span data-stu-id="15a92-124">Testing Qubit States</span></span> ###

<span data-ttu-id="15a92-125">Na prática, as asserções dependem do fato de que as simulações clássicas da mecânica quantum não precisam obedecer à [teorema no-Cloning](https://arxiv.org/abs/quant-ph/9607018), de modo que podemos fazer medidas e asserções não físicas ao usar um simulador para o nosso computador de destino.</span><span class="sxs-lookup"><span data-stu-id="15a92-125">In practice, assertions rely on the fact that classical simulations of quantum mechanics need not obey the [no-cloning theorem](https://arxiv.org/abs/quant-ph/9607018), such that we can make unphysical measurements and assertions when using a simulator for our target machine.</span></span>
<span data-ttu-id="15a92-126">Portanto, podemos testar operações individuais em um simulador clássico antes de implantar em hardware.</span><span class="sxs-lookup"><span data-stu-id="15a92-126">Thus, we can test individual operations on a classical simulator before deploying on hardware.</span></span>
<span data-ttu-id="15a92-127">Em computadores de destino que não permitem a avaliação de asserções, as chamadas para <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> podem ser ignoradas com segurança.</span><span class="sxs-lookup"><span data-stu-id="15a92-127">On target machines which do not allow evaluation of assertions, calls to <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> can be safely ignored.</span></span>

<span data-ttu-id="15a92-128">Em geral, a <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operação declara que medir o qubits fornecido na base Pauli especificada sempre terá o resultado especificado.</span><span class="sxs-lookup"><span data-stu-id="15a92-128">More generally, the <xref:Microsoft.Quantum.Diagnostics.AssertMeasurement> operation asserts that measuring the given qubits in the given Pauli basis will always have the given result.</span></span>
<span data-ttu-id="15a92-129">Se a asserção falhar, a execução terminará chamando `fail` com a mensagem fornecida.</span><span class="sxs-lookup"><span data-stu-id="15a92-129">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="15a92-130">Por padrão, essa operação não é implementada; os simuladores que podem oferecer suporte a ele devem fornecer uma implementação que executa a verificação de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="15a92-130">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="15a92-131">`AssertMeasurement` tem assinatura `((Pauli[], Qubit[], Result, String) -> ())` .</span><span class="sxs-lookup"><span data-stu-id="15a92-131">`AssertMeasurement` has signature `((Pauli[], Qubit[], Result, String) -> ())`.</span></span>
<span data-ttu-id="15a92-132">Como `AssertMeasurement` é uma função com uma tupla vazia como seu tipo de saída, nenhum efeito de tendo chamado `AssertMeasurement` é observável em um :::no-loc(Q#)::: programa.</span><span class="sxs-lookup"><span data-stu-id="15a92-132">Since `AssertMeasurement` is a function with an empty tuple as its output type, no effects from having called `AssertMeasurement` are observable within a :::no-loc(Q#)::: program.</span></span>

<span data-ttu-id="15a92-133">A <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> função de operação Asserts que medindo o determinado qubits na base de Pauli especificada terá o resultado fornecido com a probabilidade determinada, dentro de certa tolerância.</span><span class="sxs-lookup"><span data-stu-id="15a92-133">The <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> operation function asserts that measuring the given qubits in the given Pauli basis will have the given result with the given probability, within some tolerance.</span></span>
<span data-ttu-id="15a92-134">A tolerância é aditiva (por exemplo, `abs(expected-actual) < tol` ).</span><span class="sxs-lookup"><span data-stu-id="15a92-134">Tolerance is additive (for example, `abs(expected-actual) < tol`).</span></span>
<span data-ttu-id="15a92-135">Se a asserção falhar, a execução terminará chamando `fail` com a mensagem fornecida.</span><span class="sxs-lookup"><span data-stu-id="15a92-135">If the assertion fails, the run ends by calling `fail` with the given message.</span></span>
<span data-ttu-id="15a92-136">Por padrão, essa operação não é implementada; os simuladores que podem oferecer suporte a ele devem fornecer uma implementação que executa a verificação de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="15a92-136">By default, this operation is not implemented; simulators that can support it should provide an implementation that performs runtime checking.</span></span>
<span data-ttu-id="15a92-137">`AssertMeasurementProbability` tem assinatura `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)` .</span><span class="sxs-lookup"><span data-stu-id="15a92-137">`AssertMeasurementProbability` has signature `((Pauli[], Qubit[], Result, Double, String, Double) -> Unit)`.</span></span> <span data-ttu-id="15a92-138">O primeiro dos `Double` parâmetros fornece a probabilidade desejada do resultado e o segundo a tolerância.</span><span class="sxs-lookup"><span data-stu-id="15a92-138">The first of `Double` parameters gives the desired probability of the result, and the second one the tolerance.</span></span>

<span data-ttu-id="15a92-139">Podemos fazer mais do que declarar uma única medida, usando que as informações clássicas usadas por um simulador para representar o estado interno de um qubit é receptivos para copiar, de modo que não precisamos realmente executar uma medida para testar nossa declaração.</span><span class="sxs-lookup"><span data-stu-id="15a92-139">We can do more than assert a single measurement, using that the classical information used by a simulator to represent the internal state of a qubit is amenable to copying, such that we do not need to actually perform a measurement to test our assertion.</span></span>
<span data-ttu-id="15a92-140">Em particular, isso nos permite motivos sobre medidas *incompatíveis* que seriam impossíveis em hardware real.</span><span class="sxs-lookup"><span data-stu-id="15a92-140">In particular, this allows us to reason about *incompatible* measurements that would be impossible on actual hardware.</span></span>

<span data-ttu-id="15a92-141">Suponha que `P : Qubit => Unit` seja uma operação destinada a preparar o estado $ \ket{\psi} $ quando sua entrada estiver no estado $ \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="15a92-141">Suppose that `P : Qubit => Unit` is an operation intended to prepare the state $\ket{\psi}$ when its input is in the state $\ket{0}$.</span></span>
<span data-ttu-id="15a92-142">Deixe que $ \ket{\psi '} $ seja o estado real preparado pelo `P` .</span><span class="sxs-lookup"><span data-stu-id="15a92-142">Let $\ket{\psi'}$ be the actual state prepared by `P`.</span></span>
<span data-ttu-id="15a92-143">Em seguida, $ \ket{\psi} = \ket{\psi '} $ If e only se medindo $ \ket{\psi '} $ no eixo descrito por $ \ket{\psi} $ sempre retorna `Zero` .</span><span class="sxs-lookup"><span data-stu-id="15a92-143">Then, $\ket{\psi} = \ket{\psi'}$ if and only if measuring $\ket{\psi'}$ in the axis described by $\ket{\psi}$ always returns `Zero`.</span></span>
<span data-ttu-id="15a92-144">Ou seja, \begin{align} \ket{\psi} = \ket{\psi '} \Text{If e only if} \braket{\psi | \psi '} = 1.</span><span class="sxs-lookup"><span data-stu-id="15a92-144">That is, \begin{align} \ket{\psi} = \ket{\psi'} \text{ if and only if } \braket{\psi | \psi'} = 1.</span></span>
<span data-ttu-id="15a92-145">\end{align} usando as operações primitivas definidas no prelúdio, podemos executar diretamente uma medida que retorna `Zero` se $ \ket{\psi} $ for um eigenstate de um dos operadores Pauli.</span><span class="sxs-lookup"><span data-stu-id="15a92-145">\end{align} Using the primitive operations defined in the prelude, we can directly perform a measurement that returns `Zero` if $\ket{\psi}$ is an eigenstate of one of the Pauli operators.</span></span>


<span data-ttu-id="15a92-146">A operação <xref:Microsoft.Quantum.Diagnostics.AssertQubit> fornece uma abreviação particularmente útil para fazer isso no caso em que desejarmos testar a asserção $ \ket{\psi} = \ket {0} $.</span><span class="sxs-lookup"><span data-stu-id="15a92-146">The operation <xref:Microsoft.Quantum.Diagnostics.AssertQubit> provides a particularly useful shorthand to do so in the case that we wish to test the assertion $\ket{\psi} = \ket{0}$.</span></span>
<span data-ttu-id="15a92-147">Isso é comum, por exemplo, quando não computamos para retornar ancilla qubits a $ \ket {0} $ antes de liberá-los.</span><span class="sxs-lookup"><span data-stu-id="15a92-147">This is common, for instance, when we have uncomputed to return ancilla qubits to $\ket{0}$ before releasing them.</span></span>
<span data-ttu-id="15a92-148">A declaração em relação a $ \ket {0} $ também é útil quando desejamos declarar que as operações de preparação de dois Estados preparam `P` `Q` o mesmo estado e quando o `Q` dá suporte ao `Adjoint` .</span><span class="sxs-lookup"><span data-stu-id="15a92-148">Asserting against $\ket{0}$ is also useful when we wish to assert that two state preparation `P` and `Q` operations both prepare the same state, and when `Q` supports `Adjoint`.</span></span>
<span data-ttu-id="15a92-149">Em particular,</span><span class="sxs-lookup"><span data-stu-id="15a92-149">In particular,</span></span>

```qsharp
using (register = Qubit()) {
    P(register);
    Adjoint Q(register);

    AssertQubit(Zero, register);
}
```

<span data-ttu-id="15a92-150">No entanto, em geral, talvez não tenhamos acesso a asserções sobre Estados que não coincidem com eigenstates de operadores Pauli.</span><span class="sxs-lookup"><span data-stu-id="15a92-150">More generally, however, we may not have access to assertions about states that do not coincide with eigenstates of Pauli operators.</span></span>
<span data-ttu-id="15a92-151">Por exemplo, $ \ket{\psi} = (\ket {0} + e ^ {i \pi/8} \ket {1} )/\sqrt {2} $ não é um eigenstate de nenhum operador Pauli, de modo que não podemos usar <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> para determinar exclusivamente que um estado $ \ket{\psi '} $ é igual a $ \ket{\psi} $.</span><span class="sxs-lookup"><span data-stu-id="15a92-151">For example, $\ket{\psi} = (\ket{0} + e^{i \pi / 8} \ket{1}) / \sqrt{2}$ is not an eigenstate of any Pauli operator, such that we cannot use <xref:Microsoft.Quantum.Diagnostics.AssertMeasurementProbability> to uniquely determine that a state $\ket{\psi'}$ is equal to $\ket{\psi}$.</span></span>
<span data-ttu-id="15a92-152">Em vez disso, devemos decompor a asserção $ \ket{\psi '} = \ket{\psi} $ em suposições que podem ser diretamente testadas usando os primitivos suportados pelo nosso simulador.</span><span class="sxs-lookup"><span data-stu-id="15a92-152">Instead, we must decompose the assertion $\ket{\psi'} = \ket{\psi}$ into assumptions that can be directly tested using  the primitives supported by our simulator.</span></span>
<span data-ttu-id="15a92-153">Para fazer isso, deixe $ \ket{\psi} = \alpha \ket {0} + \beta \ket {1} $ para números complexos $ \alpha = \_ r + a \_ i $ e $ \beta $.</span><span class="sxs-lookup"><span data-stu-id="15a92-153">To do so, let $\ket{\psi} = \alpha \ket{0} + \beta \ket{1}$ for complex numbers $\alpha = a\_r + a\_i i$ and $\beta$.</span></span>
<span data-ttu-id="15a92-154">Observe que essa expressão requer quatro números reais \{ de $ a \_ r, a \_ i, b \_ r, b \_ i \} $ para especificar, pois cada número complexo pode ser expresso como a soma de uma parte real e imaginário.</span><span class="sxs-lookup"><span data-stu-id="15a92-154">Note that this expression requires four real numbers $\{a\_r, a\_i, b\_r, b\_i\}$ to specify, as each complex number can be expressed as the sum of a real and imaginary part.</span></span>
<span data-ttu-id="15a92-155">No entanto, devido à fase global, podemos escolher $a \_ i = $0, de modo que precisamos apenas de três números reais para especificar exclusivamente um estado de qubit único.</span><span class="sxs-lookup"><span data-stu-id="15a92-155">Due to the global phase, however, we can choose $a\_i = 0$, such that we only need three real numbers to uniquely specify a single-qubit state.</span></span>

<span data-ttu-id="15a92-156">Portanto, precisamos especificar três asserções que são independentes umas das outras para declarar o estado esperado.</span><span class="sxs-lookup"><span data-stu-id="15a92-156">Thus, we need to specify three assertions which are independent of each other in order to assert the state that we expect.</span></span>
<span data-ttu-id="15a92-157">Fazemos isso encontrando a probabilidade de observar `Zero` cada medição de Pauli, considerando $ \alpha $ e $ \beta $, e declarando cada uma independentemente.</span><span class="sxs-lookup"><span data-stu-id="15a92-157">We do so by finding the probability of observing `Zero` for each Pauli measurement given $\alpha$ and $\beta$, and asserting each independently.</span></span>
<span data-ttu-id="15a92-158">Deixe $x $, $y $ e $z $ sejam `Result` valores para Pauli $X $, $Y $ e $Z $ medições, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="15a92-158">Let $x$, $y$, and $z$ be `Result` values for Pauli $X$, $Y$, and $Z$ measurements respectively.</span></span>
<span data-ttu-id="15a92-159">Em seguida, usando a função probabilidade para medições Quantum, \begin{align} \Pr (x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ r + a \_ i b \_ i \\ \\ \Pr (y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a \_ r b \_ i-a \_ i b \_ r \\ \\ \Pr (z = \texttt{zero} | \alpha, \beta) & = \frac12\left (1 + a \_ r ^ 2 + a \_ i ^ 2 + b \_ r ^ 2 + b \_ i ^ 2 \right).</span><span class="sxs-lookup"><span data-stu-id="15a92-159">Then, using the likelihood function for quantum measurements, \begin{align} \Pr(x = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_r + a\_i b\_i \\\\ \Pr(y = \texttt{Zero} | \alpha, \beta) & = \frac12 + a\_r b\_i - a\_i b\_r \\\\ \Pr(z = \texttt{Zero} | \alpha, \beta) & = \frac12\left( 1 + a\_r^2 + a\_i^2 + b\_r^2 + b\_i^2 \right).</span></span>
<span data-ttu-id="15a92-160">\end{align}</span><span class="sxs-lookup"><span data-stu-id="15a92-160">\end{align}</span></span>

<span data-ttu-id="15a92-161">A <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operação implementa essas asserções dadas as representações de $ \alpha $ e $ \beta $ como valores do tipo <xref:Microsoft.Quantum.Math.Complex> .</span><span class="sxs-lookup"><span data-stu-id="15a92-161">The <xref:Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance> operation implements these assertions given representations of $\alpha$ and $\beta$ as values of type <xref:Microsoft.Quantum.Math.Complex>.</span></span>
<span data-ttu-id="15a92-162">Isso é útil quando o estado esperado pode ser calculado matematicamente.</span><span class="sxs-lookup"><span data-stu-id="15a92-162">This is helpful when the expected state can be computed mathematically.</span></span>

### <a name="asserting-equality-of-quantum-operations"></a><span data-ttu-id="15a92-163">Declarando a igualdade de operações Quantum</span><span class="sxs-lookup"><span data-stu-id="15a92-163">Asserting Equality of Quantum Operations</span></span> ###

<span data-ttu-id="15a92-164">Até agora, estamos preocupados com as operações de teste que destinam-se a preparar Estados específicos.</span><span class="sxs-lookup"><span data-stu-id="15a92-164">Thus far, we have been concerned with testing operations which are intended to prepare particular states.</span></span>
<span data-ttu-id="15a92-165">No entanto, muitas vezes estamos interessados em como uma operação atua para entradas arbitrárias em vez de uma única entrada fixa.</span><span class="sxs-lookup"><span data-stu-id="15a92-165">Often, however, we are interested in how an operation acts for arbitrary inputs rather than for a single fixed input.</span></span>
<span data-ttu-id="15a92-166">Por exemplo, suponha que implementamos uma operação `U : ((Double, Qubit[]) => () : Adjoint)` correspondente a uma família de operadores unitários $U (t) $ e fornecemos um `adjoint` bloco explícito em vez de usar `adjoint auto` .</span><span class="sxs-lookup"><span data-stu-id="15a92-166">For example, suppose we have implemented an operation `U : ((Double, Qubit[]) => () : Adjoint)` corresponding to a family of unitary operators $U(t)$, and have provided an explicit `adjoint` block instead of using `adjoint auto`.</span></span>
<span data-ttu-id="15a92-167">Talvez esteja interessado em afirmar que $U ^ \dagger (t) = U (-t) $, conforme esperado se $t $ representa um tempo de evolução.</span><span class="sxs-lookup"><span data-stu-id="15a92-167">We may be interested in asserting that $U^\dagger(t) = U(-t)$, as expected if $t$ represents an evolution time.</span></span>

<span data-ttu-id="15a92-168">Em geral, há duas estratégias diferentes que podemos seguir para fazer a asserção de que duas operações `U` e agir de forma `V` idêntica.</span><span class="sxs-lookup"><span data-stu-id="15a92-168">Broadly speaking, there are two different strategies that we can follow in making the assertion that two operations `U` and `V` act identically.</span></span>
<span data-ttu-id="15a92-169">Primeiro, podemos verificar se `U(target); (Adjoint V)(target);` preserva cada Estado em uma determinada base.</span><span class="sxs-lookup"><span data-stu-id="15a92-169">First, we can check that `U(target); (Adjoint V)(target);` preserves each state in a given basis.</span></span>
<span data-ttu-id="15a92-170">Em segundo lugar, podemos verificar que `U(target); (Adjoint V)(target);` agir na metade de um estado confusas preserva esse Entanglement.</span><span class="sxs-lookup"><span data-stu-id="15a92-170">Second, we can check that `U(target); (Adjoint V)(target);` acting on half of an entangled state preserves that entanglement.</span></span>
<span data-ttu-id="15a92-171">Essas estratégias são implementadas pelas operações de Canon <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> e <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced> , respectivamente.</span><span class="sxs-lookup"><span data-stu-id="15a92-171">These strategies are implemented by the canon operations <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace> and <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced>, respectively.</span></span>

> [!NOTE]
> <span data-ttu-id="15a92-172">A declaração referenciada mencionada acima funciona com base no [Choi – Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), uma estrutura matemática que relaciona as operações em $n $ qubits a confusas Estados em $2n $ qubits.</span><span class="sxs-lookup"><span data-stu-id="15a92-172">The referenced assertion discussed above works based on the [Choi–Jamiłkowski isomorphism](https://en.wikipedia.org/wiki/Channel-state_duality), a mathematical framework which relates operations on $n$ qubits to entangled states on $2n$ qubits.</span></span>
> <span data-ttu-id="15a92-173">Em particular, a operação de identidade em $n $ qubits é representada por $n as cópias do estado confusas $ \ket{\ beta_ {00} } \mathrel{: =} (\ket {00} + \ket {11} )/\sqrt {2} $.</span><span class="sxs-lookup"><span data-stu-id="15a92-173">In particular, the identity operation on $n$ qubits is represented by $n$ copies of the entangled state $\ket{\beta_{00}} \mathrel{:=} (\ket{00} + \ket{11}) / \sqrt{2}$.</span></span>
> <span data-ttu-id="15a92-174">A operação <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implementa esse isomorphism, preparando um estado que representa uma determinada operação.</span><span class="sxs-lookup"><span data-stu-id="15a92-174">The operation <xref:Microsoft.Quantum.Preparation.PrepareChoiState> implements this isomorphism, preparing a state that represents a given operation.</span></span>

<span data-ttu-id="15a92-175">Aproximadamente, essas estratégias são diferenciadas por uma compensação de espaço em tempo.</span><span class="sxs-lookup"><span data-stu-id="15a92-175">Roughly, these strategies are distinguished by a time–space tradeoff.</span></span>
<span data-ttu-id="15a92-176">A iteração em cada Estado de entrada leva mais tempo, ao passo que o uso de Entanglement como referência requer o armazenamento de qubits adicionais.</span><span class="sxs-lookup"><span data-stu-id="15a92-176">Iterating through each input state takes additional time, while using entanglement as a reference requires storing additional qubits.</span></span>
<span data-ttu-id="15a92-177">Nos casos em que uma operação implementa uma operação clássica reversível, de modo que estamos interessados apenas em seu comportamento nos Estados de base computacional, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> testa a igualdade nesse conjunto restrito de entradas.</span><span class="sxs-lookup"><span data-stu-id="15a92-177">In cases where an operation implements a reversible classical operation, such that we are only interested in its behavior on computational basis states, <xref:Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis> tests equality on this restricted set of inputs.</span></span>

> [!TIP]
> <span data-ttu-id="15a92-178">A iteração sobre Estados de entrada é tratada pelas operações de enumeração <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> e <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower> .</span><span class="sxs-lookup"><span data-stu-id="15a92-178">The iteration over input states is handled by the enumeration operations <xref:Microsoft.Quantum.Canon.IterateThroughCartesianProduct> and <xref:Microsoft.Quantum.Canon.IterateThroughCartesianPower>.</span></span>
> <span data-ttu-id="15a92-179">Essas operações são úteis mais geralmente para aplicar uma operação a cada elemento do produto cartesiano entre dois ou mais conjuntos.</span><span class="sxs-lookup"><span data-stu-id="15a92-179">These operations are useful more generally for applying an operation to each element of the Cartesian product between two or more sets.</span></span>

<span data-ttu-id="15a92-180">Mais importante, no entanto, as duas abordagens testam diferentes propriedades das operações em exame.</span><span class="sxs-lookup"><span data-stu-id="15a92-180">More critically, however, the two approaches test different properties of the operations under examination.</span></span>
<span data-ttu-id="15a92-181">Como a declaração in-loco chama cada operação várias vezes, uma vez para cada Estado de entrada, quaisquer escolhas aleatórias e resultados de medidas podem ser alterados entre as chamadas.</span><span class="sxs-lookup"><span data-stu-id="15a92-181">Since the in-place assertion calls each operation multiple times, once for each input state, any random choices and measurement results might change between calls.</span></span>
<span data-ttu-id="15a92-182">Por outro lado, a declaração referenciada chama cada operação exatamente uma vez, de modo que ela verifica se as operações são iguais *em uma única captura* .</span><span class="sxs-lookup"><span data-stu-id="15a92-182">By contrast, the referenced assertion calls each operation exactly once, such that it checks that the operations are equal *in a single shot* .</span></span>
<span data-ttu-id="15a92-183">Esses dois testes são úteis para garantir a exatidão dos programas Quantum.</span><span class="sxs-lookup"><span data-stu-id="15a92-183">Both of these tests are useful in ensuring the correctness of quantum programs.</span></span>


## <a name="further-reading"></a><span data-ttu-id="15a92-184">Leitura Adicional</span><span class="sxs-lookup"><span data-stu-id="15a92-184">Further Reading</span></span> ##

- <xref:microsoft.quantum.guide.testingdebugging>
- <xref:Microsoft.Quantum.Diagnostics>
