---
title: Visão geral do programa Q#
description: Aprenda a estrutura básica de um programa Quantum e como ele representa transformações de Estados Quantum.
author: QuantumWriter
ms.author: Christopher.Granade@microsoft.com
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.techniques.file-structure
ms.openlocfilehash: 5c75bb5499efac2c49cbfc4555fd15b3e072181c
ms.sourcegitcommit: 6ccea4a2006a47569c4e2c2cb37001e132f17476
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/28/2020
ms.locfileid: "77907691"
---
# <a name="q-program-overview"></a><span data-ttu-id="b6c1d-103">Visão geral do programa Q#</span><span class="sxs-lookup"><span data-stu-id="b6c1d-103">Q# program overview</span></span>

<span data-ttu-id="b6c1d-104">O Q # é uma linguagem de programação específica de domínio de vários paradigmas escalonáveis para a computação Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-104">Q# is a scalable, multi-paradigm, domain-specific programming language for quantum computing.</span></span> <span data-ttu-id="b6c1d-105">Q # é uma linguagem de programação Quantum no que pode ser usada para descrever como as instruções são executadas em computadores Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-105">Q# is a quantum programming language in that it can be used to describe how instructions are executed on quantum machines.</span></span> <span data-ttu-id="b6c1d-106">Os computadores que podem ser direcionados variam de simuladores até o hardware Quantum real.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-106">The machines that can be targeted range from simulators to actual quantum hardware.</span></span> <span data-ttu-id="b6c1d-107">O Q # é escalonável: pode ser usado para escrever programas de demonstração simples, como teleport, que são executados em alguns qubits, mas também oferece suporte à criação de programas grandes e sofisticados, como simulações de moléculas complexas que exigirão máquinas grandes com milhões de qubits.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-107">Q# is scalable: it can be used to write simple demonstration programs like teleport that run on a few qubits, but also supports writing large, sophisticated programs such as simulations of complex molecules that will require large machines with millions of qubits.</span></span> <span data-ttu-id="b6c1d-108">Embora grandes máquinas físicas ainda estejam no futuro, o Q # permite que um programador programe algoritmos de Quantum complexos agora.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-108">Even though large physical machines are still in the future, Q# allows a programmer to program complex quantum algorithms now.</span></span> <span data-ttu-id="b6c1d-109">O que é mais, Q # dá suporte a várias tarefas, como depuração, criação de perfil, estimativa de recursos e determinadas simulações de finalidade especial de maneira escalonável.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-109">What is more, Q# supports various tasks such as debugging, profiling, resource estimation, and certain special-purpose simulations in a scalable way.</span></span> 

<span data-ttu-id="b6c1d-110">Do ponto de vista técnico, um programa Quantum pode ser visto como um conjunto específico de funções clássicas que, quando chamado, geram circuitos Quantum como seus efeitos colaterais.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-110">From a technical perspective, a quantum program can be seen as a particular set of classical functions which, when called, generate quantum circuits as their side effects.</span></span> <span data-ttu-id="b6c1d-111">Uma consequência importante dessa exibição é que um programa escrito em Q # não modele diretamente o qubits em si, mas descreve como um computador de controle clássico interage com esses qubits.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-111">An important consequence of that view is that a program written in Q# does not directly model qubits themselves, but rather describes how a classical control computer interacts with those qubits.</span></span>
<span data-ttu-id="b6c1d-112">Por design, p #, portanto, não define os Estados Quantum ou outras propriedades da mecânica quantum diretamente, mas sim indiretamente por meio da ação das várias sub-rotinas definidas no idioma.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-112">By design, Q# thus does not define quantum states or other properties of quantum mechanics directly, but rather does so indirectly through the action of the various subroutines defined in the language.</span></span>
<span data-ttu-id="b6c1d-113">Por exemplo, considere o estado $ \ket{+} = \left (\ket{0} + \ket{1}\right)/\sqrt{2}$ discutido no guia de [conceitos da computação Quantum](xref:microsoft.quantum.concepts.intro) .</span><span class="sxs-lookup"><span data-stu-id="b6c1d-113">For instance, consider the state $\ket{+} = \left(\ket{0} + \ket{1}\right) / \sqrt{2}$ discussed in the [Quantum Computing Concepts](xref:microsoft.quantum.concepts.intro) guide.</span></span>
<span data-ttu-id="b6c1d-114">Para preparar esse estado em Q #, usamos os fatos que os qubits são inicializados no estado $ \ket{0}$ e que $ \ket{+} = H\ket{0}$, em que $H $ é a transformação Hadamard:</span><span class="sxs-lookup"><span data-stu-id="b6c1d-114">To prepare this state in Q#, we use the facts that the qubits are initialized in the $\ket{0}$ state, and that $\ket{+} = H\ket{0}$, where $H$ is the Hadamard transform:</span></span>

```qsharp
using (qubit = Qubit()) {
    // At this point, qubit is in the state |0〉.
    H(qubit);
    // We've now applied H, such that our qubit is in H|0〉 = |+〉, as we wanted.
}
```
## <a name="q-tranformations-of-quantum-states"></a><span data-ttu-id="b6c1d-115">Q # tranformations de Estados da Quantum</span><span class="sxs-lookup"><span data-stu-id="b6c1d-115">Q# tranformations of quantum states</span></span>

<span data-ttu-id="b6c1d-116">O mais importante é que, ao escrever o programa acima, não nos referimos explicitamente ao estado em Q #, mas, em vez disso, descrevemos como o estado foi *transformado* por nosso programa.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-116">Importantly, in writing the above program, we did not explicitly refer to the state within Q#, but rather described how the state was *transformed* by our program.</span></span>
<span data-ttu-id="b6c1d-117">Assim, assim como um programa de sombreador de gráficos acumula uma descrição de transformações em cada vértice, um programa Quantum em Q # acumula transformações em Estados Quantum.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-117">Thus, similar to how a graphics shader program accumulates a description of transformations to each vertex, a quantum program in Q# accumulates transformations to quantum states.</span></span>
<span data-ttu-id="b6c1d-118">Isso nos permite ser totalmente independente do que um estado Quantum ainda *está* em cada computador de destino, que pode ter interpretações diferentes dependendo do computador.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-118">This allows us to be entirely agnostic about what a quantum state even *is* on each target machine, which might have different interpretations depending on the machine.</span></span> 

<span data-ttu-id="b6c1d-119">Da perspectiva de um programa Q #, um qubit é uma referência totalmente opaca à estrutura interna de um computador de destino.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-119">From the perspective of a Q# program, a qubit is an entirely opaque reference to the internal structure of a target machine.</span></span>
<span data-ttu-id="b6c1d-120">Um programa Q # não tem a capacidade de introspecção no estado de um qubit, sua representação em um computador de destino ou até mesmo se ele é o mesmo qubit que qualquer outro qubit disponível para o programa.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-120">A Q# program has no ability to introspect into the state of a qubit, its representation on a target machine, or even whether it is the same qubit as any other qubit available to the program.</span></span>
<span data-ttu-id="b6c1d-121">Em vez disso, um programa pode chamar operações como `Measure` para aprender informações de um qubit e chamar operações como `X` e `H` para agir no estado de um qubit.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-121">Rather, a program can call operations such as `Measure` to learn information from a qubit, and call operations such as `X` and `H` to act on the state of a qubit.</span></span>
<span data-ttu-id="b6c1d-122">Essas operações não têm nenhuma definição intrínseca dentro do idioma e se tornam concretas apenas pela máquina de destino usada para executar um programa de Q # específico.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-122">These operations have no intrinsic definition within the language, and are made concrete only by the target machine used to run a particular Q# program.</span></span>
<span data-ttu-id="b6c1d-123">Um programa Q # recombina essas operações conforme definido por um computador de destino para criar operações novas e de nível mais alto para a computação da Quantum Express.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-123">A Q# program recombines these operations as defined by a target machine to create new, higher-level operations to express quantum computation.</span></span>
<span data-ttu-id="b6c1d-124">Dessa forma, o Q # torna fácil expressar os algoritmos Quantum subjacente e Quantum híbrido clássico, além de ser geral em relação à estrutura de um computador de destino ou simulador.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-124">In this way, Q# makes it easy to express the logic underlying quantum and hybrid quantum-classical algorithms, while also being general with respect to the structure of a target machine or simulator.</span></span>

## <a name="q-operations-and-functions"></a><span data-ttu-id="b6c1d-125">Operações e funções do Q #</span><span class="sxs-lookup"><span data-stu-id="b6c1d-125">Q# operations and functions</span></span>

<span data-ttu-id="b6c1d-126">Concretamente, um programa Q # é composto de uma ou mais *operações*, uma ou mais *funções*e tipos definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-126">Concretely, a Q# program is comprised of one or more *operations*, one or more *functions*, and user defined types.</span></span> <span data-ttu-id="b6c1d-127">As operações são usadas para descrever as transformações do estado de uma máquina Quantum e são o bloco de construção mais básico de programas do Q #.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-127">Operations are used to describe the transformations of the state of a quantum machine and are the most basic building block of Q# programs.</span></span> <span data-ttu-id="b6c1d-128">Cada operação definida em Q # pode então chamar qualquer número de outras operações, incluindo as operações *intrínsecas* internas implementadas por um computador de destino.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-128">Each operation defined in Q# may then call any number of other operations, including the built-in *intrinsic* operations implemented by a target machine.</span></span>
<span data-ttu-id="b6c1d-129">Quando compilada, cada operação é representada como um tipo de classe do .NET que pode ser fornecido para os computadores de destino.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-129">When compiled, each operation is represented as a .NET class type that can be provided to target machines.</span></span>

<span data-ttu-id="b6c1d-130">Em contraste com as operações, as funções são usadas para descrever o comportamento puramente clássico e não têm nenhum efeito além de calcular os valores de saída clássicas.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-130">In contrast to operations, functions are used to describe purely classical behavior and do not have any effects besides computing classical output values.</span></span> <span data-ttu-id="b6c1d-131">Q # é uma linguagem fortemente tipada e vem com um conjunto de tipos primitivos internos, bem como suporte para tipos definidos pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-131">Q# is a strongly typed language and comes with a set of built-in primitive types as well as support for user defined types.</span></span> 

<span data-ttu-id="b6c1d-132">Durante o restante deste guia, veremos como usar diferentes conceitos de linguagem e construções para nos ajudar a definir programas de Quantum complexos por meio dos blocos de construção básicos de operações, funções e tipos.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-132">Throughout the rest of this guide, we will see how to use different language concepts and constructs to help us define complex quantum programs through the basic building blocks of operations, functions, and types.</span></span> 

## <a name="structure-of-q-source-files"></a><span data-ttu-id="b6c1d-133">Estrutura de arquivos de origem do Q #</span><span class="sxs-lookup"><span data-stu-id="b6c1d-133">Structure of Q# Source Files</span></span>

<span data-ttu-id="b6c1d-134">No mínimo, um arquivo de origem Q # consiste em uma *declaração de namespace*, que especifica um namespace .NET que conterá as definições no arquivo de origem.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-134">Minimally, a Q# source file consists of a *namespace declaration*, which specifies a .NET namespace which will contain the definitions in the source file.</span></span>
<span data-ttu-id="b6c1d-135">As definições de outros arquivos de origem Q # e bibliotecas podem ser incluídas usando a instrução `open`.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-135">Definitions from other Q# source files and libraries can be included using the `open` statement.</span></span>
<span data-ttu-id="b6c1d-136">Por exemplo, a maioria das operações que definem Gates fundamentais são definidas no namespace <xref:microsoft.quantum.intrinsic>.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-136">For instance, most of the operations defining fundamental gates are defined in the <xref:microsoft.quantum.intrinsic> namespace.</span></span>
<span data-ttu-id="b6c1d-137">Para disponibilizar isso para nosso código, simplesmente `open` o namespace na parte superior de cada arquivo:</span><span class="sxs-lookup"><span data-stu-id="b6c1d-137">To make this available to our code, we simply `open` that namespace at the top of each file:</span></span>

```qsharp
namespace Example {
    open Microsoft.Quantum.Intrinsic;

    // ...
}
```

<span data-ttu-id="b6c1d-138">Dentro de um namespace, cada arquivo de origem Q # pode definir qualquer combinação de *operações*, *funções*e *tipos definidos pelo usuário*.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-138">Within a namespace, each Q# source file can define any combination of *operations*, *functions*, and *user-defined types*.</span></span>
<span data-ttu-id="b6c1d-139">No restante desta seção, descreveremos cada uma delas por vez e forneceremos exemplos de como elas podem ser usadas na prática para criar programas de Quantum úteis.</span><span class="sxs-lookup"><span data-stu-id="b6c1d-139">In the rest of this section, we will describe each in turn and provide examples of how they can be used in practice to make useful quantum programs.</span></span>
