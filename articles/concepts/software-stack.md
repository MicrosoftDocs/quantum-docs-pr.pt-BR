---
title: Pilha de software | Microsoft Docs
description: Pilha de software
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184722"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="61500-103">Pilha de software para computação Quantum</span><span class="sxs-lookup"><span data-stu-id="61500-103">Software stack for quantum computing</span></span>
<span data-ttu-id="61500-104">Normalmente, quando pensamos em um computador, prevemos um único dispositivo executando um aplicativo, mas os ambientes de computação modernos são muito mais complexos e avançados.</span><span class="sxs-lookup"><span data-stu-id="61500-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="61500-105">O aplicativo que interagimos normalmente reside em várias camadas de software que fornecem a execução do aplicativo para o nível de hardware.</span><span class="sxs-lookup"><span data-stu-id="61500-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="61500-106">Essas camadas de software são necessárias para abstrair o desenvolvimento de uma solução de aplicativo da complexidade subjacente do sistema de computação completo.</span><span class="sxs-lookup"><span data-stu-id="61500-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="61500-107">Se um desenvolvedor tivesse de pensar em barramento, arquiteturas de cache, protocolos de comunicação e muito mais durante a gravação de um aplicativo de smartphone simples, a tarefa seria muito mais complexa.</span><span class="sxs-lookup"><span data-stu-id="61500-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="61500-108">O conceito de uma *pilha de software* foi desenvolvido na computação clássica para resolver esses problemas.</span><span class="sxs-lookup"><span data-stu-id="61500-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="61500-109">Com o empréstimo do conceito clássico, uma pilha de software também é uma parte fundamental da visão por trás da computação Quantum com Q #.</span><span class="sxs-lookup"><span data-stu-id="61500-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="61500-110">Pilha convencional</span><span class="sxs-lookup"><span data-stu-id="61500-110">Conventional stack</span></span>
<span data-ttu-id="61500-111">A ideia principal por trás de uma pilha de software é a recursão.</span><span class="sxs-lookup"><span data-stu-id="61500-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="61500-112">Ele consiste em várias camadas aninhadas de interfaces que abstraim os detalhes dos níveis inferiores do dispositivo para fora do desenvolvedor.</span><span class="sxs-lookup"><span data-stu-id="61500-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="61500-113">Por exemplo, uma pilha de software comumente usada envolve a execução de ASP.NET (uma linguagem de programação), além do SQL Server (um sistema de gerenciamento de banco de dados relacional), que é executado sobre o Serviços de Informações da Internet (um servidor Web), que é executado no Windows Server (um sistema operacional), que orienta o hardware do computador.</span><span class="sxs-lookup"><span data-stu-id="61500-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="61500-114">Examinando o software como uma hierarquia, é possível escrever software em ASP.NET sem a necessidade de entender os detalhes de baixo nível de todo o software abaixo dele.</span><span class="sxs-lookup"><span data-stu-id="61500-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="61500-115">Pilha Quantum</span><span class="sxs-lookup"><span data-stu-id="61500-115">Quantum stack</span></span>

<span data-ttu-id="61500-116">A pilha de software na computação Quantum não é diferente em princípio e, na prática, opera em um nível mais baixo do que as pilhas tradicionais.</span><span class="sxs-lookup"><span data-stu-id="61500-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="61500-117">Como é a aparência de uma pilha Quantum?</span><span class="sxs-lookup"><span data-stu-id="61500-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="61500-118">Um computador Quantum não é uma substituição para computadores tradicionais (geralmente chamados de clássico).</span><span class="sxs-lookup"><span data-stu-id="61500-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="61500-119">Na verdade, os computadores Quantum quase certamente funcionarão em conjunto com computadores clássicos para resolver problemas computacionais.</span><span class="sxs-lookup"><span data-stu-id="61500-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="61500-120">Em parte, isso ocorre devido ao fragilidade de dados Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="61500-121">Os dados Quantum são tão frágeis que, se você olhar até mesmo, certamente danificará as informações que estão sendo observadas.</span><span class="sxs-lookup"><span data-stu-id="61500-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="61500-122">Os computadores Quantum, portanto, precisarão ser projetados com a correção de erro Quantum em mente para que as interações isoladas de seu ambiente físico não danifiquem inadvertidamente as informações e a computação.</span><span class="sxs-lookup"><span data-stu-id="61500-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="61500-123">Por esse motivo, um destino natural para Q # é um computador Quantum corrigido por erro (geralmente chamado de computador Quantum *tolerante a falhas* ) que aceita uma lista de instruções Quantum (chamadas de operações de Gates ou de entrada) e aplica essas instruções à Quantum dados armazenados nele.</span><span class="sxs-lookup"><span data-stu-id="61500-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="61500-124">Observe que, se o número de operações de qubits e de portão em um algoritmo ou programa Quantum for pequeno o suficiente, a correção de erro pode não ser absolutamente necessária.</span><span class="sxs-lookup"><span data-stu-id="61500-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="61500-125">No entanto, como o número de operações de qubits e portão aumenta, certamente será um requisito, portanto, arquitetamos nossa pilha de software e Q # para lidar com a correção de erros de forma apropriada e eficiente e habilitar a computação Quantum escalonável e tolerante a falhas.</span><span class="sxs-lookup"><span data-stu-id="61500-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="61500-126">Correção de erro</span><span class="sxs-lookup"><span data-stu-id="61500-126">Error correction</span></span>
<span data-ttu-id="61500-127">A correção de erros requer que um computador clássico rápido e confiável seja executado em conjunto com o computador Quantum para corrigir erros à medida que eles aparecem na computação Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="61500-128">Na prática, os componentes como FPGAs (matrizes de Portable programáveis) ou processadores de Cryogenic rápidos podem ser necessários para identificar e corrigir os erros mais rapidamente do que eles se acumulam naturalmente no computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="61500-129">Como resultado, um computador Quantum é um computador híbrido composto por vários dispositivos computacionais diferentes que operam em uma ampla gama de temperaturas.</span><span class="sxs-lookup"><span data-stu-id="61500-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="61500-130">Por esse motivo, é muito mais útil pensar em programação de um computador Quantum por meio da lente de uma pilha de software, pois há muitas camadas de hardware e software (clássica e Quantum) necessárias para atingir a implementação de um Quantum algoritmo em um computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="61500-131">Pilha conceitual do Quantum</span><span class="sxs-lookup"><span data-stu-id="61500-131">Quantum conceptual stack</span></span>
<span data-ttu-id="61500-132">Uma pilha conceitual que ilustra o fluxo funcional de fatoração 8704143553785700723 em um ambiente de computação Quantum é mostrada abaixo:</span><span class="sxs-lookup"><span data-stu-id="61500-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![Pilha de software](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="61500-134">Especificação e algoritmo</span><span class="sxs-lookup"><span data-stu-id="61500-134">Specification and algorithm</span></span>
<span data-ttu-id="61500-135">Há vários estágios amplos de programação, como uma computação Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="61500-136">A primeira e, de uma fase mais desafiadora, é especificar o problema que um deseja resolver.</span><span class="sxs-lookup"><span data-stu-id="61500-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="61500-137">Nesse caso, o problema é fatorar o número 8704143553785700723 em um produto de dois números primos.</span><span class="sxs-lookup"><span data-stu-id="61500-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="61500-138">A próxima etapa envolve a criação de um algoritmo para resolver esse problema computacional.</span><span class="sxs-lookup"><span data-stu-id="61500-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="61500-139">Nesse caso, o famoso algoritmo de fatoração Quantum da Atal pode ser usado para encontrar os fatores.</span><span class="sxs-lookup"><span data-stu-id="61500-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="61500-140">Esse algoritmo é expresso em Q # e, em seguida, uma sequência de operações Quantum é uma saída que pode ser executada em um computador Quantum sem erros ideal.</span><span class="sxs-lookup"><span data-stu-id="61500-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="61500-141">Gates físicos</span><span class="sxs-lookup"><span data-stu-id="61500-141">Physical gates</span></span>
<span data-ttu-id="61500-142">Neste exemplo, suponha que a natureza não seja tão como fornecer um computador Quantum sem erros para que a etapa subsequente use as operações emitidas por Q # e as traduza usando modelos especificados pelo método de correção de erro Quantum escolhido em Gates físicos que o hardware básico pode ser executado.</span><span class="sxs-lookup"><span data-stu-id="61500-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="61500-143">Esse processo envolve a substituição de todos os qubit lógicos descritos no modelo anterior por um host de qubits físicos que são usados para armazenar e proteger as informações em um único qubit de maneira redundante que pode resistir a erros locais nos componentes físicos qubits tempo suficiente para que esses erros sejam detectados e corrigidos.</span><span class="sxs-lookup"><span data-stu-id="61500-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="61500-144">Assim como os qubits lógicos descritos pelo código Q # precisam ser substituídos por muitos qubits físicos, de forma semelhante cada portão da Quantum descrito na saída precisa ser convertido em uma sequência de Gates físicos que atuam no qubits físico.</span><span class="sxs-lookup"><span data-stu-id="61500-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="61500-145">Por esse motivo, a saída de Q # raramente é o destino final da computação Quantum e mais níveis de abstração são necessários para executar o código em hardware de uma maneira alheios.</span><span class="sxs-lookup"><span data-stu-id="61500-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="61500-146">Computador de controle</span><span class="sxs-lookup"><span data-stu-id="61500-146">Control computer</span></span>
<span data-ttu-id="61500-147">Em seguida, a sequência de portão físico é carregada em um computador comum que envia essas instruções para um computador de controle que interage diretamente com o computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="61500-148">Essa camada na pilha de software é geralmente tratada pelo software de controle experimental, como [QCoDeS](http://qcodes.github.io/Qcodes/).</span><span class="sxs-lookup"><span data-stu-id="61500-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="61500-149">Computador de interface</span><span class="sxs-lookup"><span data-stu-id="61500-149">Interface computer</span></span>
<span data-ttu-id="61500-150">A etapa final desse processo envolve o computador da interface primeiro transmitindo as Gates conforme necessário para um computador de controle rápido.</span><span class="sxs-lookup"><span data-stu-id="61500-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="61500-151">Em seguida, o computador de controle rápido aplica as tensões necessárias (geralmente chamadas de pulsos) para implementar as Gates necessárias em qubits.</span><span class="sxs-lookup"><span data-stu-id="61500-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="61500-152">Isso deve ser feito ao corrigir quaisquer erros observados por meio da correção de erro Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="61500-153">O Cryogenic FPGAs ou outro hardware exóticas pode ser necessário para executar essas etapas dentro dos rigorosos requisitos de tempo impostos pela taxa na qual os erros aparecem no computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="61500-154">O idioma de destino nesse nível geralmente é [VHDL](https://en.wikipedia.org/wiki/VHDL), o que exige uma maneira distinta de pensar no que é usado na extremidade superior da pilha para analisar uma descrição de um algoritmo Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="61500-155">A linguagem de programação da Quantum do Q #</span><span class="sxs-lookup"><span data-stu-id="61500-155">The Q# quantum programming language</span></span>
<span data-ttu-id="61500-156">O objetivo do Q # é fornecer uma linguagem simples que permita aos desenvolvedores escrever código direcionado a uma infinidade de plataformas e interfaces de computação Quantum com as camadas intermediárias de software que se deparam entre o usuário e o dispositivo Quantum.</span><span class="sxs-lookup"><span data-stu-id="61500-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="61500-157">A linguagem facilita isso adotando a noção de uma pilha de software e abstraindo muitos dos detalhes do computador Quantum subjacente, enquanto permite outros níveis da pilha, expostos por meio de uma linguagem como C#, para executar a traduções do código Q # para operações fundamentais.</span><span class="sxs-lookup"><span data-stu-id="61500-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="61500-158">Isso permite que o desenvolvedor se concentre no que eles fazem melhor: criando algoritmos e resolvendo problemas.</span><span class="sxs-lookup"><span data-stu-id="61500-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
