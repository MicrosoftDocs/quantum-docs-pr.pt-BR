---
title: O qubit na computação Quantum
description: Saiba mais sobre o qubits, a unidade fundamental de informações na computação Quantum.
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
no-loc:
- $
- $
- $
- $
- $
- $
- '\cdots'
- bmatrix
- '\ddots'
- '\equiv'
- '\sum'
- '\begin'
- '\end'
- '\sqrt'
- '\otimes'
- '{'
- '}'
- '\text'
- '\phi'
- '\kappa'
- '\psi'
- '\alpha'
- '\beta'
- '\gamma'
- '\delta'
- '\omega'
- '\bra'
- '\ket'
- '\boldone'
- '\\\\'
- '\\'
- =
- '\frac'
- '\text'
- '\mapsto'
- '\dagger'
- '\to'
- "\begin{cases}"
- "\end{cases}"
- '\operatorname'
- '\braket'
- '\id'
- '\expect'
- '\defeq'
- '\variance'
- '\dd'
- '&'
- "\begin{align}"
- "\end{align}"
- '\Lambda'
- '\lambda'
- '\Omega'
- '\mathrm'
- '\left'
- '\right'
- '\qquad'
- '\times'
- '\big'
- '\langle'
- '\rangle'
- '\bigg'
- '\Big'
- '|'
- '\mathbb'
- '\vec'
- '\in'
- '\texttt'
- '\ne'
- <
- '>'
- '\leq'
- '\geq'
- ~~
- "~"
- "\begin{bmatrix}"
- "\end{bmatrix}"
- '\_'
ms.openlocfilehash: 0b768190137aa4effe0fbac9c764dff60ec00e16
ms.sourcegitcommit: 0181e7c9e98f9af30ea32d3cd8e7e5e30257a4dc
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 06/23/2020
ms.locfileid: "85269568"
---
# <a name="the-qubit"></a><span data-ttu-id="9f15d-103">O qubit</span><span class="sxs-lookup"><span data-stu-id="9f15d-103">The Qubit</span></span>

<span data-ttu-id="9f15d-104">Assim como os bits são o objeto fundamental das informações na computação clássica, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (bits Quantum) são o objeto fundamental das informações na computação Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="9f15d-105">Para entender essa correspondência, vamos examinar o exemplo mais simples: um único qubit.</span><span class="sxs-lookup"><span data-stu-id="9f15d-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="9f15d-106">Representando um qubit</span><span class="sxs-lookup"><span data-stu-id="9f15d-106">Representing a Qubit</span></span>

<span data-ttu-id="9f15d-107">Um pouco, ou dígito binário, pode ter valor $ de $0 ou $1 $ , um qubit pode ter um valor que seja um destes ou uma superposição quantum de $0 $ e $1 $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="9f15d-108">O estado de um único qubit pode ser descrito por um vetor de coluna bidimensional da norma de unidade, ou seja, a magnitude quadrada de suas entradas deve somar $1 $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="9f15d-109">Esse vetor, chamado de vetor de estado Quantum, contém todas as informações necessárias para descrever o sistema Quantum qubit, assim como um único bit contém todas as informações necessárias para descrever o estado de uma variável binária.</span><span class="sxs-lookup"><span data-stu-id="9f15d-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="9f15d-110">Qualquer vetor de coluna bidimensional de números reais ou complexos com a norma $1 $ representa um possível estado de Quantum mantido por um qubit.</span><span class="sxs-lookup"><span data-stu-id="9f15d-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="9f15d-111">Portanto, $ \begin{ bmatrix } \alpha \\ \\ \beta \end{ bmatrix } $ representa um estado de qubit se $ \alpha $ e $ \beta $ forem números complexos que atendem a $ | \alpha | ^ 2 + | \beta | ^ 2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="9f15d-112">Alguns exemplos de vetores de estado de Quantum válidos que representam qubits incluem</span><span class="sxs-lookup"><span data-stu-id="9f15d-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="9f15d-113">$ $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , \begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac{1 } {\sqrt{2 } } \end{ bmatrix } , \begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac { -1 } {\sqrt{2 } } \end{ bmatrix } , \Text { e} \begin{ bmatrix } \frac{1 } {\sqrt{2 } } \\ \\ \frac{i } {\sqrt{2 } } \end{ bmatrix } . $ $</span><span class="sxs-lookup"><span data-stu-id="9f15d-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="9f15d-114">Os vetores de estado Quantum $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ e $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $ usam uma função especial.</span><span class="sxs-lookup"><span data-stu-id="9f15d-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="9f15d-115">Esses dois vetores formam uma base para o espaço vetorial que descreve o estado do qubit.</span><span class="sxs-lookup"><span data-stu-id="9f15d-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="9f15d-116">Isso significa que qualquer vetor de estado de Quantum pode ser escrito como uma soma desses vetores de base.</span><span class="sxs-lookup"><span data-stu-id="9f15d-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="9f15d-117">Especificamente, o vetor $ \begin{ bmatrix } x \\ \\ y \end{ bmatrix } $ pode ser escrito como $x \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } + y \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="9f15d-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="9f15d-118">Embora qualquer rotação desses vetores sirva como uma base perfeitamente válida para o qubit, optamos por fazer um privilégio para esse, chamando-o na *base computacional*.</span><span class="sxs-lookup"><span data-stu-id="9f15d-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="9f15d-119">Pegamos esses dois Estados de Quantum para corresponder aos dois Estados de um bit clássico, especificamente $0 $ e $1 $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="9f15d-120">A convenção padrão é escolher</span><span class="sxs-lookup"><span data-stu-id="9f15d-120">The standard convention is to choose</span></span>

<span data-ttu-id="9f15d-121">US $ $0 \equiv \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } , \qquad 1 \equiv \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } , $ $</span><span class="sxs-lookup"><span data-stu-id="9f15d-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="9f15d-122">Embora a escolha oposta pudesse ser igualmente bem executada.</span><span class="sxs-lookup"><span data-stu-id="9f15d-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="9f15d-123">Portanto, fora do número infinito de vetores de estado de Quantum de qubit único, apenas dois correspondem a Estados de bits clássicos; todos os outros Estados de Quantum não.</span><span class="sxs-lookup"><span data-stu-id="9f15d-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="9f15d-124">Medindo um qubit</span><span class="sxs-lookup"><span data-stu-id="9f15d-124">Measuring a Qubit</span></span>

<span data-ttu-id="9f15d-125">Agora que sabemos como representar um qubit, podemos obter alguma intuição para o que esses Estados representam discutindo o conceito de [*medida*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span><span class="sxs-lookup"><span data-stu-id="9f15d-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="9f15d-126">Uma medida corresponde à ideia informal de "olhando" em um qubit, que recolhe imediatamente o estado da Quantum para um dos dois Estados clássicos $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ ou $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="9f15d-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="9f15d-127">Quando um qubit fornecido pelo vetor de estado do Quantum $ \begin{ bmatrix } \alpha \\ \\ \beta \end{ bmatrix } $ for medido, obteremos o resultado $0 $ com probabilidade $ | \alpha | ^ 2 $ e o resultado $1 $ com probabilidade $ | \beta | ^ 2 $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="9f15d-128">No resultado $0 $ , o novo estado do qubit é $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $; no resultado $1, $ seu estado é $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="9f15d-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="9f15d-129">Observe que essas probabilidades somam até $1 $ devido à condição de normalização $ | \alpha | ^ 2 + | \beta | ^ 2 = 1 $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="9f15d-130">As propriedades de medida também significam que o sinal geral do vetor de estado do Quantum é irrelevante.</span><span class="sxs-lookup"><span data-stu-id="9f15d-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="9f15d-131">Negar um vetor é equivalente a $ \alpha \rightarrow-\alpha $ e $ \beta \rightarrow-\beta $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="9f15d-132">Como a probabilidade de medir $0 $ e $1 $ depende da magnitude dos termos, inserir tais sinais não altera as probabilidades de qualquer forma.</span><span class="sxs-lookup"><span data-stu-id="9f15d-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="9f15d-133">Essas fases geralmente são chamadas de [ \`\` *fases globais*' '](https://en.wikipedia.org/wiki/Phase_factor) e mais geralmente podem ser do formato $e ^ {i \phi } $ em vez de apenas $ \pm 1 $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="9f15d-134">Uma propriedade final importante da medição é que ela não necessariamente danifica todos os vetores de estado da Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="9f15d-135">Se começarmos com um qubit no estado $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $, que corresponde ao estado clássico $0 $ , medir esse estado sempre produzirá o resultado $0 $ e deixará o estado Quantum inalterado.</span><span class="sxs-lookup"><span data-stu-id="9f15d-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="9f15d-136">Nesse sentido, se tivermos apenas bits clássicos (ou seja, qubits que são $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } $ ou $ \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $), a medição não danificará o sistema.</span><span class="sxs-lookup"><span data-stu-id="9f15d-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="9f15d-137">Isso significa que podemos replicar dados clássicos e manipulá-los em um computador Quantum da mesma forma que um pode fazer em um computador clássico.</span><span class="sxs-lookup"><span data-stu-id="9f15d-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="9f15d-138">No entanto, a capacidade de armazenar informações em ambos os Estados de uma vez é o que eleva a computação Quantum além do que é possível, de forma clássica, e mais Robs da capacidade de copiar dados Quantum indiscriminadamente, consulte também [o teorema no-Cloning](https://en.wikipedia.org/wiki/No-cloning_theorem).</span><span class="sxs-lookup"><span data-stu-id="9f15d-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="9f15d-139">Visualizando qubits e transformações usando a esfera Bloch</span><span class="sxs-lookup"><span data-stu-id="9f15d-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="9f15d-140">Qubits também pode ser pictureed em $3 $ D usando a representação de [*esfera Bloch*](https://en.wikipedia.org/wiki/Bloch_sphere) .</span><span class="sxs-lookup"><span data-stu-id="9f15d-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="9f15d-141">A esfera Bloch fornece uma maneira de descrever um estado de Quantum de qubit único (que é um vetor complexo bidimensional) como um vetor de valor real tridimensional.</span><span class="sxs-lookup"><span data-stu-id="9f15d-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="9f15d-142">Isso é importante porque permite visualizar Estados de qubit único e, assim, desenvolver motivos que podem ser inestimávels na compreensão de Estados de qubit (onde infelizmente a representação de esfera de Bloch é interrompida).</span><span class="sxs-lookup"><span data-stu-id="9f15d-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="9f15d-143">A esfera Bloch pode ser visualizada da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="9f15d-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="9f15d-144">![Esfera de Bloch](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="9f15d-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="9f15d-145">As setas neste diagrama mostram a direção em que o vetor de estado do Quantum está apontando e cada transformação da seta pode ser considerada como uma rotação sobre um dos eixos cardinal.</span><span class="sxs-lookup"><span data-stu-id="9f15d-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="9f15d-146">Embora pensar em uma computação Quantum como uma sequência de rotações seja uma intuição poderosa, é desafiador usar essa intuição para projetar e descrever algoritmos.</span><span class="sxs-lookup"><span data-stu-id="9f15d-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="9f15d-147">Q # alivia esse problema fornecendo uma linguagem para descrever essas rotações.</span><span class="sxs-lookup"><span data-stu-id="9f15d-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="9f15d-148">Operações de qubit único</span><span class="sxs-lookup"><span data-stu-id="9f15d-148">Single-Qubit Operations</span></span>

<span data-ttu-id="9f15d-149">Os computadores Quantum processam dados aplicando um conjunto universal de Gates de Quantum que podem emular qualquer rotação do vetor de estado Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="9f15d-150">Essa noção de universação é semelhante à noção de universalidade para computação tradicional (ou seja, clássica), em que um conjunto de portão é considerado universal se cada transformação dos bits de entrada puder ser executada usando um circuito de comprimento finito.</span><span class="sxs-lookup"><span data-stu-id="9f15d-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="9f15d-151">Na computação Quantum, as transformações válidas que temos permissão para executar em um qubit são transformações e medição de unitários.</span><span class="sxs-lookup"><span data-stu-id="9f15d-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="9f15d-152">A *operação de adjoin* ou a Transpose de conjugada complexa é de importância crucial para a computação Quantum porque é necessária para inverter as transformações Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="9f15d-153">O Q # reflete isso fornecendo métodos para Compilar automaticamente as sequências de porta para seu adjacente, o que evita que o programador tenha de codificar o código adjoints em muitos casos.</span><span class="sxs-lookup"><span data-stu-id="9f15d-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="9f15d-154">Um exemplo disso é mostrado abaixo:</span><span class="sxs-lookup"><span data-stu-id="9f15d-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="9f15d-155">Embora esse seja um exemplo trivial (como a <xref:microsoft.quantum.intrinsic.h>  a operação é self-prejoin), você pode ver como isso se torna inestimável para operações qubit mais complicadas.</span><span class="sxs-lookup"><span data-stu-id="9f15d-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="9f15d-156">Para obter mais informações, consulte [operações e funções](xref:microsoft.quantum.guide.operationsfunctions).</span><span class="sxs-lookup"><span data-stu-id="9f15d-156">For more information, see [Operations and Functions](xref:microsoft.quantum.guide.operationsfunctions).</span></span>

<span data-ttu-id="9f15d-157">Há apenas quatro funções que mapeiam um bit para um bit em um computador clássico.</span><span class="sxs-lookup"><span data-stu-id="9f15d-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="9f15d-158">Por outro lado, há um número infinito de transformações de unitários em um único qubit em um computador Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="9f15d-159">Portanto, nenhum conjunto finito de operações primitivas de Quantum, chamado [*Gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), pode replicar exatamente o conjunto infinito de transformações de unitários permitidas na computação Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="9f15d-160">Isso significa que, diferentemente da computação clássica, é impossível para um computador Quantum implementar cada programa Quantum possível usando exatamente um número finito de Gates.</span><span class="sxs-lookup"><span data-stu-id="9f15d-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="9f15d-161">Assim, os computadores Quantum não podem ser universais no mesmo sentido dos computadores clássicos.</span><span class="sxs-lookup"><span data-stu-id="9f15d-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="9f15d-162">Como resultado, quando dizemos que um conjunto de Gates é *Universal* para computação Quantum, na verdade queremos dizer algo um pouco mais fraco do que queremos dizer com a computação clássica.</span><span class="sxs-lookup"><span data-stu-id="9f15d-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="9f15d-163">Para a universalidade, exigimos que um computador Quantum só se *aproxima* de cada matriz unitário dentro de um erro finito usando uma sequência de portão de comprimento finito.</span><span class="sxs-lookup"><span data-stu-id="9f15d-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="9f15d-164">Em outras palavras, um conjunto de Gates será um conjunto de portão universal se qualquer transformação unitário puder ser aproximadamente gravada como um produto de Gates desse conjunto.</span><span class="sxs-lookup"><span data-stu-id="9f15d-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="9f15d-165">Exigimos que, para qualquer erro prescrito associado, exista Gates $G _ {1 } , G_ {2 } , \ldots, G_N $ do conjunto de portas de modo que</span><span class="sxs-lookup"><span data-stu-id="9f15d-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="9f15d-166">$ $ G_N G_ {N-1 } \cdots G_2 G_1 \Approx U. $ $</span><span class="sxs-lookup"><span data-stu-id="9f15d-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="9f15d-167">Observe que, como a Convenção para multiplicação de matriz é multiplicada da direita para a esquerda a primeira operação de portão nessa sequência, $G _N $ , na verdade, é a última aplicada ao vetor de estado Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="9f15d-168">Mais formalmente, dizemos que esse conjunto de portão é universal se para cada tolerância de erro $ \epsilon>0 $ existir $G _1, \ldots, G_N $ de modo que a distância entre $G _N \ldots G_1 $ e $U $ seja no máximo $ \epsilon $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="9f15d-169">Idealmente, o valor de $N $ necessário para atingir essa distância de $ \epsilon $ deve dimensionar o logaritmicamente com US $1/\ Épsilon $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="9f15d-170">Como funciona a aparência desse tipo de porta universal na prática?</span><span class="sxs-lookup"><span data-stu-id="9f15d-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="9f15d-171">O conjunto mais simples desse tipo de porta universal para Gates de qubit consiste em apenas dois Gates: o portão Hadamard $H $ e o chamado $T $ -Gate (também conhecido como a porta $ \ PI/8 $ ):</span><span class="sxs-lookup"><span data-stu-id="9f15d-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="9f15d-172">$ $ H = \frac{1 } {\sqrt{2 } } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad T = \begin{ bmatrix } 1 & 0 \\ \\ 0 & e ^ {i \ pi/4 } \end{ bmatrix } .</span><span class="sxs-lookup"><span data-stu-id="9f15d-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="9f15d-173">No entanto, por motivos práticos relacionados à correção de erro Quantum, pode ser mais conveniente considerar um conjunto de portão maior, ou seja, um que pode ser gerado usando $H $ e $T $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="9f15d-174">Podemos classificar os Gates Quantum em duas categorias: Clifford Gates e o $T $ -Gate.</span><span class="sxs-lookup"><span data-stu-id="9f15d-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="9f15d-175">Essa subdivisão é útil porque, em muitos esquemas de correção de erros Quantum, os chamados Clifford Gates são fáceis de implementar, ou seja, eles exigem muito poucos recursos em termos de operações e qubits para implementar a falha de forma tolerante, enquanto as Gates não Clifford são muito dispendiosas quando exigem tolerância a falhas.</span><span class="sxs-lookup"><span data-stu-id="9f15d-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="9f15d-176">O conjunto padrão de Gates de Clifford de qubit único, [incluído por padrão em Q #](xref:microsoft.quantum.libraries.standard.prelude), inclui</span><span class="sxs-lookup"><span data-stu-id="9f15d-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="9f15d-177">$ $ H = \frac{1 } {\sqrt{2 } } \begin{ bmatrix } 1 & 1 \\ \\ 1 &-1 \end{ bmatrix } , \qquad S = \begin{ bmatrix } 1 & 0 \\ \\ 0 & i \end{ bmatrix } = T ^ 2, \qquad X = \begin{ bmatrix } 0 &1 \\ \\ 1 & 0 \end{ bmatrix } = HT ^ 4h, $ $</span><span class="sxs-lookup"><span data-stu-id="9f15d-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="9f15d-178">$ $ Y = \begin{ bmatrix } 0 &-i \\ \\ i & 0 \END{ bmatrix } = T ^ 2HT ^ 4 HT ^ 6, \qquad Z = \begin{ bmatrix } 1&0 \\\\ 0 & -1 \end{ bmatrix } = T ^ 4.</span><span class="sxs-lookup"><span data-stu-id="9f15d-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="9f15d-179">Aqui, as operações $X $ , $Y $ e $Z $ são usadas especialmente frequentemente e são nomeadas como [*operadores Pauli*](https://en.wikipedia.org/wiki/Pauli_matrices) depois de seu criador Wolfgang Pauli.</span><span class="sxs-lookup"><span data-stu-id="9f15d-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="9f15d-180">Junto com o portão não Clifford (o $T $ -Gate), essas operações podem ser compostas para aproximar qualquer transformação unitário em um único qubit.</span><span class="sxs-lookup"><span data-stu-id="9f15d-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="9f15d-181">Para obter mais informações sobre essas operações, suas representações de esfera Bloch e implementações de Q #, consulte [operações e funções intrínsecas](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span><span class="sxs-lookup"><span data-stu-id="9f15d-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="9f15d-182">Como exemplo de como as transformações de unitários podem ser criadas com base nesses primitivos, as três transformações modeladas nos Blochs acima correspondem à sequência de portão $ \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } \mapsto HZH \begin{ bmatrix } 1 \\ \\ 0 \end{ bmatrix } = \begin{ bmatrix } 0 \\ \\ 1 \end{ bmatrix } $.</span><span class="sxs-lookup"><span data-stu-id="9f15d-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="9f15d-183">Embora o anterior constitua os Gates primitivos mais populares para descrever as operações no nível lógico da pilha (Pense no nível lógico como o nível do algoritmo Quantum), geralmente é conveniente considerar menos operações básicas no nível de algoritmo, por exemplo, operações mais próximas de um nível de descrição de função.</span><span class="sxs-lookup"><span data-stu-id="9f15d-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="9f15d-184">Felizmente, o Q # também tem métodos disponíveis para a implementação de unidades de nível superior, que, por sua vez, permitem que algoritmos de alto nível sejam implementados sem decompor explicitamente tudo em Clifford e $T $ Gates.</span><span class="sxs-lookup"><span data-stu-id="9f15d-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="9f15d-185">O mais simples desses primitivos é a única rotação de qubit.</span><span class="sxs-lookup"><span data-stu-id="9f15d-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="9f15d-186">Três rotações de qubit são geralmente consideradas: $R _x $ , $R _y $ e $R _z $ .</span><span class="sxs-lookup"><span data-stu-id="9f15d-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="9f15d-187">Para visualizar a ação do $R de rotação _x (\theta) $, por exemplo, imagine apontar seu polegar à direita ao longo da direção do $ eixo de $x da esfera Bloch e girar o vetor com sua mão por meio de um ângulo de $ \ teta/2 $ radianos.</span><span class="sxs-lookup"><span data-stu-id="9f15d-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="9f15d-188">Esse fator confuso de $2 $ surge desde o fato de que os vetores ortogonal são $180 ^ \circs $ quando plotados na esfera Bloch, mas, na verdade, são de US $90 ^ \circ $ graus geométricos.</span><span class="sxs-lookup"><span data-stu-id="9f15d-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="9f15d-189">As matrizes de unitário correspondentes são:</span><span class="sxs-lookup"><span data-stu-id="9f15d-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="9f15d-190">\begin{align *} &R_z (\theta) = e ^ {-i\theta z/2 } = \begin{ bmatrix } e ^ {-i \ teta/2 } & 0 \\\\ 0 & e ^ {i \ teta/2 } \end{ bmatrix } , \\ \\ &R_x (\theta) = e ^ {-i\theta x/2 } = HR_z (\theta) H = \begin{ bmatrix } \cos (\ teta/2) &-i\sin (\ teta/2) \\ \\ -i\sin (\ teta/2) & \cos (\ teta/2) \end{ bmatrix } , \\ \\ &R_y (\theta) = e ^ {-i\theta y/2 } = SHR_z (\theta) HS ^ \dagger = \begin{ bmatrix } \cos (\ teta/2) &-\sin (\ teta/2) \\ \\ \sin (\ teta/2) & \cos (\ teta/2) \end{ bmatrix } . \end{align*}</span><span class="sxs-lookup"><span data-stu-id="9f15d-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="9f15d-191">Assim como as três rotações podem ser combinadas para executar uma rotação arbitrária em três dimensões, ela pode ser vista na representação de Sphere Bloch que qualquer matriz de unitário também pode ser gravada como uma sequência de três rotações.</span><span class="sxs-lookup"><span data-stu-id="9f15d-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="9f15d-192">Especificamente, para cada matriz unitário $U $ existe $ \alpha, \beta, \gamma, \delta de $ forma que $U = e ^ {i \alpha } R_x (\beta) R_z (\gamma) R_x (\delta) $.</span><span class="sxs-lookup"><span data-stu-id="9f15d-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="9f15d-193">Assim, $R _z (\theta) $ e $H $ também formam um conjunto de portão universal, embora não seja um conjunto discreto porque $ \theta $ pode usar qualquer valor.</span><span class="sxs-lookup"><span data-stu-id="9f15d-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="9f15d-194">Por esse motivo, e devido a aplicativos na simulação do Quantum, esses Gates contínuos são cruciais para computação Quantum, especialmente no nível de design do algoritmo Quantum.</span><span class="sxs-lookup"><span data-stu-id="9f15d-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="9f15d-195">Para obter a implementação de hardware tolerante a falhas, elas serão eventualmente compiladas em sequências de porta discretas que aproximam-se dessas rotações.</span><span class="sxs-lookup"><span data-stu-id="9f15d-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
